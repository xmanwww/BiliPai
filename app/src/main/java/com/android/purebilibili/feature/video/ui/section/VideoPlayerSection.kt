// æ–‡ä»¶è·¯å¾„: feature/video/VideoPlayerSection.kt
package com.android.purebilibili.feature.video.ui.section

import com.android.purebilibili.feature.video.danmaku.DanmakuManager
import com.android.purebilibili.feature.video.danmaku.FaceOcclusionDanmakuContainer
import com.android.purebilibili.feature.video.danmaku.FaceOcclusionMaskStabilizer
import com.android.purebilibili.feature.video.danmaku.FaceOcclusionModuleState
import com.android.purebilibili.feature.video.danmaku.FaceOcclusionVisualMask
import com.android.purebilibili.feature.video.danmaku.checkFaceOcclusionModuleState
import com.android.purebilibili.feature.video.danmaku.createFaceOcclusionDetector
import com.android.purebilibili.feature.video.danmaku.detectFaceOcclusionRegions
import com.android.purebilibili.feature.video.danmaku.installFaceOcclusionModule
import com.android.purebilibili.feature.video.danmaku.rememberDanmakuManager
import com.android.purebilibili.feature.video.state.VideoPlayerState
import com.android.purebilibili.feature.video.viewmodel.PlayerUiState
import com.android.purebilibili.feature.video.ui.overlay.VideoPlayerOverlay
import com.android.purebilibili.feature.video.ui.overlay.SubtitleControlCallbacks
import com.android.purebilibili.feature.video.ui.overlay.SubtitleControlUiState
import com.android.purebilibili.feature.video.ui.components.SponsorSkipButton
import com.android.purebilibili.feature.video.ui.components.VideoAspectRatio
import com.android.purebilibili.data.model.response.ViewPoint

import android.app.Activity
import android.content.Context
import android.content.ContextWrapper
import android.view.LayoutInflater
import android.media.AudioManager
import android.provider.Settings
import android.widget.Toast
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.clickable
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.animation.*
import androidx.compose.animation.core.tween
import androidx.activity.compose.BackHandler
//  Cupertino Icons - iOS SF Symbols é£æ ¼å›¾æ ‡
import io.github.alexzhirkevich.cupertino.icons.CupertinoIcons
import io.github.alexzhirkevich.cupertino.icons.outlined.*
import io.github.alexzhirkevich.cupertino.icons.filled.*
import androidx.compose.material3.*
// ğŸŒˆ Material Icons Extended - äº®åº¦å›¾æ ‡
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.BrightnessLow
import androidx.compose.material.icons.filled.BrightnessMedium
import androidx.compose.material.icons.filled.BrightnessHigh
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clipToBounds
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.zIndex
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.viewinterop.AndroidView
import coil.compose.AsyncImage
import androidx.compose.ui.layout.ContentScale
import androidx.media3.common.Player
import androidx.media3.common.VideoSize
import androidx.media3.ui.PlayerView
import com.android.purebilibili.core.util.FormatUtils
import com.android.purebilibili.feature.video.subtitle.SubtitleDisplayMode
import com.android.purebilibili.feature.video.subtitle.isSubtitleFeatureEnabledForUser
import com.android.purebilibili.feature.video.subtitle.normalizeSubtitleDisplayMode
import com.android.purebilibili.feature.video.subtitle.resolveDefaultSubtitleDisplayMode
import com.android.purebilibili.feature.video.subtitle.resolveSubtitleTextAt
import com.android.purebilibili.feature.video.subtitle.shouldRenderPrimarySubtitle
import com.android.purebilibili.feature.video.subtitle.shouldRenderSecondarySubtitle
import com.android.purebilibili.feature.video.util.captureAndSaveVideoScreenshot
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withTimeoutOrNull
import kotlin.math.abs

enum class VideoGestureMode { None, Brightness, Volume, Seek, SwipeToFullscreen }

internal fun resolveHorizontalSeekDeltaMs(
    isFullscreen: Boolean,
    fullscreenSwipeSeekEnabled: Boolean,
    totalDragDistanceX: Float,
    containerWidthPx: Float,
    fullscreenSwipeSeekSeconds: Int,
    gestureSensitivity: Float
): Long {
    if (isFullscreen && fullscreenSwipeSeekEnabled) {
        val stepWidthPx = (containerWidthPx / 8f).coerceAtLeast(1f)
        val stepCount = (totalDragDistanceX / stepWidthPx).toInt()
        val steppedDelta = stepCount * fullscreenSwipeSeekSeconds * 1000L
        if (steppedDelta != 0L) return steppedDelta
    }
    return (totalDragDistanceX * 200f * gestureSensitivity).toLong()
}

internal fun shouldCommitGestureSeek(
    currentPositionMs: Long,
    targetPositionMs: Long,
    minDeltaMs: Long = 300L
): Boolean {
    return abs(targetPositionMs - currentPositionMs) >= minDeltaMs
}

internal fun shouldUseTextureSurfaceForFlip(
    isFlippedHorizontal: Boolean,
    isFlippedVertical: Boolean
): Boolean {
    return isFlippedHorizontal || isFlippedVertical
}

internal fun resolveSubtitleLanguageLabel(
    languageCode: String?,
    fallbackLabel: String
): String {
    val normalized = languageCode?.lowercase().orEmpty()
    return when {
        normalized.contains("zh") -> "ä¸­æ–‡"
        normalized.contains("en") -> "è‹±æ–‡"
        languageCode.isNullOrBlank() -> fallbackLabel
        else -> languageCode
    }
}

internal fun shouldForceCoverDuringReturnAnimation(
    forceCoverOnly: Boolean
): Boolean {
    return forceCoverOnly
}

internal fun shouldShowCoverImage(
    isFirstFrameRendered: Boolean,
    forceCoverDuringReturnAnimation: Boolean
): Boolean {
    return forceCoverDuringReturnAnimation || !isFirstFrameRendered
}

internal fun shouldDisableCoverFadeAnimation(
    forceCoverDuringReturnAnimation: Boolean
): Boolean {
    return forceCoverDuringReturnAnimation
}

internal fun shouldPromoteFirstFrameByPlaybackFallback(
    isFirstFrameRendered: Boolean,
    forceCoverDuringReturnAnimation: Boolean,
    playbackState: Int,
    playWhenReady: Boolean,
    currentPositionMs: Long,
    videoWidth: Int,
    videoHeight: Int
): Boolean {
    if (isFirstFrameRendered || forceCoverDuringReturnAnimation) return false
    val hasVideoTrack = videoWidth > 0 && videoHeight > 0
    return hasVideoTrack &&
        playWhenReady &&
        playbackState == Player.STATE_READY &&
        currentPositionMs > 300L
}

@androidx.annotation.OptIn(androidx.media3.common.util.UnstableApi::class)
@Composable
fun VideoPlayerSection(
    playerState: VideoPlayerState,
    uiState: PlayerUiState,
    isFullscreen: Boolean,
    isInPipMode: Boolean,
    onToggleFullscreen: () -> Unit,
    onQualityChange: (Int, Long) -> Unit,
    onBack: () -> Unit,
    onDanmakuInputClick: () -> Unit = {},
    // ğŸ”— [æ–°å¢] åˆ†äº«åŠŸèƒ½
    bvid: String = "",
    coverUrl: String = "",
    //  å®éªŒæ€§åŠŸèƒ½ï¼šåŒå‡»ç‚¹èµ
    onDoubleTapLike: () -> Unit = {},
    //  ç©ºé™åŠ©æ‰‹
    sponsorSegment: com.android.purebilibili.data.model.response.SponsorSegment? = null,
    showSponsorSkipButton: Boolean = false,
    onSponsorSkip: () -> Unit = {},
    onSponsorDismiss: () -> Unit = {},
    //  [æ–°å¢] é‡è½½è§†é¢‘å›è°ƒ
    onReloadVideo: () -> Unit = {},
    //  [æ–°å¢] CDN çº¿è·¯åˆ‡æ¢
    currentCdnIndex: Int = 0,
    cdnCount: Int = 1,
    onSwitchCdn: () -> Unit = {},
    onSwitchCdnTo: (Int) -> Unit = {},
    
    //  [æ–°å¢] éŸ³é¢‘æ¨¡å¼
    isAudioOnly: Boolean = false,
    onAudioOnlyToggle: () -> Unit = {},
    
    //  [æ–°å¢] å®šæ—¶å…³é—­
    sleepTimerMinutes: Int? = null,
    onSleepTimerChange: (Int?) -> Unit = {},
    
    // ğŸ–¼ï¸ [æ–°å¢] è§†é¢‘é¢„è§ˆå›¾æ•°æ®
    videoshotData: com.android.purebilibili.data.model.response.VideoshotData? = null,
    
    // ğŸ“– [æ–°å¢] è§†é¢‘ç« èŠ‚æ•°æ®
    viewPoints: List<ViewPoint> = emptyList(),
    
    // ğŸ“± [æ–°å¢] ç«–å±å…¨å±æ¨¡å¼
    isVerticalVideo: Boolean = false,
    onPortraitFullscreen: () -> Unit = {},
    isPortraitFullscreen: Boolean = false,
    // ğŸ“² [æ–°å¢] å°çª—æ¨¡å¼
    // ğŸ“² [æ–°å¢] å°çª—æ¨¡å¼
    onPipClick: () -> Unit = {},
    // [New] Codec & Audio Params
    currentCodec: String = "hev1", 
    onCodecChange: (String) -> Unit = {},
    currentSecondCodec: String = "avc1",
    onSecondCodecChange: (String) -> Unit = {},
    currentAudioQuality: Int = -1,
    onAudioQualityChange: (Int) -> Unit = {},
    // [New] Audio Language
    onAudioLangChange: (String) -> Unit = {},
    // ğŸ‘€ [æ–°å¢] åœ¨çº¿è§‚çœ‹äººæ•°
    onlineCount: String = "",
    // [New Actions]
    onSaveCover: () -> Unit = {},
    onDownloadAudio: () -> Unit = {},
    // ğŸ” [æ–°å¢] æ’­æ”¾æ¨¡å¼
    currentPlayMode: com.android.purebilibili.feature.video.player.PlayMode = com.android.purebilibili.feature.video.player.PlayMode.SEQUENTIAL,
    onPlayModeClick: () -> Unit = {},

    // [æ–°å¢] ä¾§è¾¹æ æŠ½å±‰æ•°æ®ä¸äº¤äº’
    onRelatedVideoClick: (String, android.os.Bundle?) -> Unit = {_,_ -> },
    relatedVideos: List<com.android.purebilibili.data.model.response.RelatedVideo> = emptyList(),
    ugcSeason: com.android.purebilibili.data.model.response.UgcSeason? = null,
    isFollowed: Boolean = false,
    isLiked: Boolean = false,
    isCoined: Boolean = false,
    isFavorited: Boolean = false,
    onToggleFollow: () -> Unit = {},
    onToggleLike: () -> Unit = {},
    onCoin: () -> Unit = {},
    onToggleFavorite: () -> Unit = {},
    onTriple: () -> Unit = {},  // [æ–°å¢] ä¸€é”®ä¸‰è¿å›è°ƒ
    onPageSelect: (Int) -> Unit = {},
    forceCoverOnly: Boolean = false,
    suppressSubtitleOverlay: Boolean = false,
) {
    val context = LocalContext.current
    val configuration = LocalConfiguration.current
    val uiLayoutPolicy = remember(configuration.screenWidthDp) {
        resolveVideoPlayerUiLayoutPolicy(
            widthDp = configuration.screenWidthDp
        )
    }
    val audioManager = remember { context.getSystemService(Context.AUDIO_SERVICE) as AudioManager }
    val maxVolume = remember { audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC) }

    // --- æ–°å¢ï¼šè¯»å–è®¾ç½®ä¸­çš„"è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯"å¼€å…³ ---
    val prefs = remember { context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE) }
    // ä½¿ç”¨ rememberUpdatedState ç¡®ä¿é‡ç»„æ—¶è·å–æœ€æ–°å€¼ï¼ˆè™½ç„¶åœ¨å•ä¸€ Activity ç”Ÿå‘½å‘¨æœŸå†…å¯èƒ½éœ€è¦é‡å¯ç”Ÿæ•ˆï¼Œä½†ç®€å•åœºæ™¯å¤Ÿç”¨ï¼‰
    val showStats by remember { mutableStateOf(prefs.getBoolean("show_stats", false)) }
    
    //  [æ–°å¢] è¯»å–æ‰‹åŠ¿çµæ•åº¦è®¾ç½®
    val gestureSensitivity by com.android.purebilibili.core.store.SettingsManager
        .getGestureSensitivity(context)
        .collectAsState(initial = 1.0f)

    // ğŸ“± [ä¼˜åŒ–] realResolution ç°åœ¨ä» playerState.videoSize è®¡ç®—ï¼ˆè§ä¸‹æ–¹ï¼‰
    
    //  è¯»å–åŒå‡»ç‚¹èµè®¾ç½® (ä» DataStore è¯»å–)
    val doubleTapLikeEnabled by com.android.purebilibili.core.store.SettingsManager
        .getDoubleTapLike(context)
        .collectAsState(initial = true)
    
    //  [æ–°å¢] è¯»å–åŒå‡»è·³è½¬ç§’æ•°è®¾ç½®
    val doubleTapSeekEnabled by com.android.purebilibili.core.store.SettingsManager
        .getDoubleTapSeekEnabled(context)
        .collectAsState(initial = true)

    val portraitSwipeToFullscreenEnabled by com.android.purebilibili.core.store.SettingsManager
        .getPortraitSwipeToFullscreenEnabled(context)
        .collectAsState(initial = true)

    val seekForwardSeconds by com.android.purebilibili.core.store.SettingsManager
        .getSeekForwardSeconds(context)
        .collectAsState(initial = 10)
    val seekBackwardSeconds by com.android.purebilibili.core.store.SettingsManager
        .getSeekBackwardSeconds(context)
        .collectAsState(initial = 10)
    val fullscreenSwipeSeekSeconds by com.android.purebilibili.core.store.SettingsManager
        .getFullscreenSwipeSeekSeconds(context)
        .collectAsState(initial = 15)
    val fullscreenSwipeSeekEnabled by com.android.purebilibili.core.store.SettingsManager
        .getFullscreenSwipeSeekEnabled(context)
        .collectAsState(initial = true)
    
    //  [æ–°å¢] åŒå‡»è·³è½¬è§†è§‰åé¦ˆçŠ¶æ€
    var seekFeedbackText by remember { mutableStateOf<String?>(null) }
    var seekFeedbackVisible by remember { mutableStateOf(false) }
    
    //  [æ–°å¢] é•¿æŒ‰å€é€Ÿè®¾ç½®å’ŒçŠ¶æ€
    val longPressSpeed by com.android.purebilibili.core.store.SettingsManager
        .getLongPressSpeed(context)
        .collectAsState(initial = 2.0f)
    var isLongPressing by remember { mutableStateOf(false) }
    var originalSpeed by remember { mutableFloatStateOf(1.0f) }
    var longPressSpeedFeedbackVisible by remember { mutableStateOf(false) }
    
    //  [æ–°å¢] ç¼“å†²çŠ¶æ€ç›‘å¬
    var isBuffering by remember { mutableStateOf(false) }
    DisposableEffect(playerState.player) {
        val listener = object : Player.Listener {
            override fun onPlaybackStateChanged(playbackState: Int) {
                isBuffering = playbackState == Player.STATE_BUFFERING
            }
        }
        playerState.player.addListener(listener)
        // åˆå§‹åŒ–çŠ¶æ€
        isBuffering = playerState.player.playbackState == Player.STATE_BUFFERING
        onDispose {
            playerState.player.removeListener(listener)
        }
    }

    // ğŸ“± [ä¼˜åŒ–] å¤ç”¨ VideoPlayerState ä¸­çš„è§†é¢‘å°ºå¯¸çŠ¶æ€ï¼Œé¿å…é‡å¤ç›‘å¬
    val videoSizeState by playerState.videoSize.collectAsState()
    val realResolution = if (videoSizeState.first > 0 && videoSizeState.second > 0) {
        "${videoSizeState.first} x ${videoSizeState.second}"
    } else {
        ""
    }

    // æ§åˆ¶å™¨æ˜¾ç¤ºçŠ¶æ€
    var showControls by remember { mutableStateOf(true) }
    var playerViewRef by remember { mutableStateOf<PlayerView?>(null) }
    var faceVisualMasks by remember { mutableStateOf(emptyList<FaceOcclusionVisualMask>()) }
    val faceMaskStabilizer = remember { FaceOcclusionMaskStabilizer() }
    var smartOcclusionModuleState by remember { mutableStateOf(FaceOcclusionModuleState.Checking) }
    var smartOcclusionDownloadProgress by remember { mutableStateOf<Int?>(null) }
    
    // ğŸ”’ [æ–°å¢] å±å¹•é”å®šçŠ¶æ€ï¼ˆå…¨å±æ—¶é˜²è¯¯è§¦ï¼‰
    var isScreenLocked by remember { mutableStateOf(false) }

    var gestureMode by remember { mutableStateOf<VideoGestureMode>(VideoGestureMode.None) }
    var gestureIcon by remember { mutableStateOf<ImageVector?>(null) }
    var gesturePercent by remember { mutableFloatStateOf(0f) }

    // è¿›åº¦æ‰‹åŠ¿ç›¸å…³çŠ¶æ€
    var seekTargetTime by remember { mutableLongStateOf(0L) }
    var startPosition by remember { mutableLongStateOf(0L) }
    var isGestureVisible by remember { mutableStateOf(false) }
    
    //  è§†é¢‘æ¯”ä¾‹çŠ¶æ€
    var currentAspectRatio by remember { mutableStateOf(VideoAspectRatio.FIT) }
    
    //  [æ–°å¢] è§†é¢‘ç¿»è½¬çŠ¶æ€
    var isFlippedHorizontal by remember { mutableStateOf(false) }
    var isFlippedVertical by remember { mutableStateOf(false) }

    // è®°å½•æ‰‹åŠ¿å¼€å§‹æ—¶çš„åˆå§‹å€¼
    var startVolume by remember { mutableIntStateOf(0) }
    var startBrightness by remember { mutableFloatStateOf(0f) }

    // è®°å½•ç´¯è®¡æ‹–åŠ¨è·ç¦»
    var totalDragDistanceY by remember { mutableFloatStateOf(0f) }
    var totalDragDistanceX by remember { mutableFloatStateOf(0f) }
    // è®°å½•æ‰‹åŠ¿èµ·ç‚¹ Xï¼ˆç”¨äºé”å®šåˆ†åŒºï¼Œé¿å…æ‹–åŠ¨è¿‡ç¨‹æ¨ªå‘æ¼‚ç§»å¯¼è‡´è¯¯åˆ¤ï¼‰
    var dragStartX by remember { mutableFloatStateOf(-1f) }

    fun getActivity(): Activity? = when (context) {
        is Activity -> context
        is ContextWrapper -> context.baseContext as? Activity
        else -> null
    }

    //  [æ–°å¢] ç¼©æ”¾å’Œå¹³ç§»çŠ¶æ€
    var scale by remember { mutableFloatStateOf(1f) }
    var panX by remember { mutableFloatStateOf(0f) }
    var panY by remember { mutableFloatStateOf(0f) }

    DisposableEffect(Unit) {
        onDispose { playerViewRef = null }
    }

    // [æ–°å¢] å…±äº«å…ƒç´ è¿‡æ¸¡æ”¯æŒ
    val sharedTransitionScope = com.android.purebilibili.core.ui.LocalSharedTransitionScope.current
    val animatedVisibilityScope = com.android.purebilibili.core.ui.LocalAnimatedVisibilityScope.current
    val haptic = androidx.compose.ui.platform.LocalHapticFeedback.current
    //  å…±äº«å¼¹å¹•ç®¡ç†å™¨ï¼ˆç”¨äºæ‰€æœ‰ seek è·¯å¾„çš„ä¸€è‡´åŒæ­¥ï¼‰
    val danmakuManager = rememberDanmakuManager()
    val overlayDrawerHazeState = remember { HazeState() }

    var rootModifier = Modifier
        .fillMaxSize()
        .clipToBounds()
        .background(Color.Black)
        .hazeSource(overlayDrawerHazeState)

    // åº”ç”¨å…±äº«å…ƒç´ 
    if (bvid.isNotEmpty() && sharedTransitionScope != null && animatedVisibilityScope != null) {
         with(sharedTransitionScope) {
             rootModifier = rootModifier.sharedElement(
                 sharedContentState = rememberSharedContentState(key = "video-$bvid"),
                 animatedVisibilityScope = animatedVisibilityScope,
                 boundsTransform = { _, _ ->
                     com.android.purebilibili.core.theme.AnimationSpecs.BiliPaiSpringSpec
                 }
             )
         }
    }

    Box(
        modifier = rootModifier
            //  [æ–°å¢] å¤„ç†åŒæŒ‡ç¼©æ”¾å’Œå¹³ç§»
            .pointerInput(Unit) {
                detectTransformGestures { _, pan, zoom, _ ->
                    scale = (scale * zoom).coerceIn(1f, 5f)
                    
                    if (scale > 1f) {
                        // ç¼©æ”¾çŠ¶æ€ä¸‹ï¼Œå…è®¸å¹³ç§»
                        val maxPanX = (size.width * scale - size.width) / 2
                        val maxPanY = (size.height * scale - size.height) / 2
                        panX = (panX + pan.x * scale).coerceIn(-maxPanX, maxPanX)
                        panY = (panY + pan.y * scale).coerceIn(-maxPanY, maxPanY)
                        
                        // å¦‚æœæ­£åœ¨ç¼©æ”¾/å¹³ç§»ï¼Œéšè—æ‰‹åŠ¿å›¾æ ‡å’Œæ§åˆ¶æ 
                        isGestureVisible = false
                        showControls = false
                    } else {
                        // æ¢å¤åŸå§‹æ¯”ä¾‹æ—¶ï¼Œé‡ç½®å¹³ç§»
                        panX = 0f
                        panY = 0f
                    }
                }
            }
            //  å…ˆå¤„ç†æ‹–æ‹½æ‰‹åŠ¿ (éŸ³é‡/äº®åº¦/è¿›åº¦)
            .pointerInput(
                isInPipMode,
                isScreenLocked,
                portraitSwipeToFullscreenEnabled,
                fullscreenSwipeSeekSeconds
            ) {
                if (!isInPipMode) {
                    detectDragGestures(
                        onDragStart = { offset ->
                            // [æ–°å¢] å¦‚æœå¤„äºç¼©æ”¾çŠ¶æ€ï¼Œç¦ç”¨å¸¸è§„æ‹–æ‹½æ‰‹åŠ¿ï¼Œä¼˜å…ˆå¤„ç†å¹³ç§»
                            if (scale > 1.01f) {  // ç•™ä¸€ç‚¹æµ®ç‚¹æ•°buffer
                                return@detectDragGestures
                            }
                            
                            // ğŸ”’ é”å®šæ—¶ç¦ç”¨æ‹–æ‹½æ‰‹åŠ¿
                            if (isScreenLocked) {
                                return@detectDragGestures
                            }                
                            //  [æ–°å¢] è¾¹ç¼˜é˜²è¯¯è§¦æ£€æµ‹
                            //  å¦‚æœåœ¨å±å¹•é¡¶éƒ¨æˆ–åº•éƒ¨åŒºåŸŸå¼€å§‹æ»‘åŠ¨ï¼Œåˆ™è§†ä¸ºç³»ç»Ÿæ‰‹åŠ¿ï¼ˆå¦‚ä¸‹æ‹‰é€šçŸ¥æ ï¼‰ï¼Œä¸è§¦å‘æ’­æ”¾å™¨æ‰‹åŠ¿
                            val density = context.resources.displayMetrics.density
                            val safeZonePx = 48 * density  //  48dp å®‰å…¨åŒºåŸŸ
                            val screenHeight = size.height

                            // æ£€æŸ¥æ˜¯å¦åœ¨å®‰å…¨åŒºåŸŸå†… (é¡¶éƒ¨æˆ–åº•éƒ¨)
                            val isEdgeGesture = offset.y < safeZonePx || offset.y > (screenHeight - safeZonePx)
                            
                            if (isEdgeGesture) {
                                isGestureVisible = false
                                gestureMode = VideoGestureMode.None
                                dragStartX = -1f
                                // ä¸éœ€è¦ returnï¼Œç›´æ¥ä¸æ‰§è¡Œä¸‹é¢çš„åˆå§‹åŒ–é€»è¾‘å³å¯
                            } else {
                                isGestureVisible = true
                                gestureMode = VideoGestureMode.None
                                dragStartX = offset.x
                                totalDragDistanceY = 0f
                                totalDragDistanceX = 0f

                                startVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)
                                startPosition = playerState.player.currentPosition

                                val attributes = getActivity()?.window?.attributes
                                val currentWindowBrightness = attributes?.screenBrightness ?: -1f

                                if (currentWindowBrightness < 0) {
                                    try {
                                        val sysBrightness = Settings.System.getInt(
                                            context.contentResolver,
                                            Settings.System.SCREEN_BRIGHTNESS
                                        )
                                        startBrightness = sysBrightness / 255f
                                    } catch (e: Exception) {
                                        startBrightness = 0.5f
                                    }
                                } else {
                                    startBrightness = currentWindowBrightness
                                }
                            }
                        },
                        onDragEnd = {
                            if (gestureMode == VideoGestureMode.Seek) {
                                val currentPosition = playerState.player.currentPosition
                                if (shouldCommitGestureSeek(
                                        currentPositionMs = currentPosition,
                                        targetPositionMs = seekTargetTime
                                    )
                                ) {
                                    playerState.player.seekTo(seekTargetTime)
                                    danmakuManager.seekTo(seekTargetTime)
                                }
                                playerState.player.play()
                            } else if (gestureMode == VideoGestureMode.SwipeToFullscreen) {
                                //  é˜ˆå€¼åˆ¤å®šï¼šä¸Šæ»‘è¶…è¿‡ä¸€å®šè·ç¦»è§¦å‘å…¨å±
                                val swipeThreshold = 50.dp.toPx()
                                if (portraitSwipeToFullscreenEnabled &&
                                    totalDragDistanceY < -swipeThreshold &&
                                    !isFullscreen
                                ) {
                                    onToggleFullscreen()
                                    // éœ‡åŠ¨åé¦ˆ (å¯é€‰)
                                    haptic.performHapticFeedback(androidx.compose.ui.hapticfeedback.HapticFeedbackType.LongPress)
                                    com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "ğŸ‘† Swipe up to fullscreen triggered")
                                }
                            }
                            isGestureVisible = false
                            gestureMode = VideoGestureMode.None
                            dragStartX = -1f
                        },
                        onDragCancel = {
                            isGestureVisible = false
                            gestureMode = VideoGestureMode.None
                            dragStartX = -1f
                        },
                        //  [ä¿®å¤ç‚¹] ä½¿ç”¨ dragAmount è€Œä¸æ˜¯ change.positionChange()
                        onDrag = { change, dragAmount ->
                            // å¦‚æœæ‰‹åŠ¿ä¸å¯è§ï¼ˆå³åœ¨ safe zone ä¸­å¯åŠ¨è¢«å¿½ç•¥ï¼‰ï¼Œåˆ™åœæ­¢å¤„ç†
                            if (!isGestureVisible && gestureMode == VideoGestureMode.None) {
                                // do nothing
                            } else {
                            
                            // [ä¿®å¤] ç´¯ç§¯æ‹–åŠ¨è·ç¦»ï¼Œç”¨äºæ›´å‡†ç¡®çš„æ–¹å‘åˆ¤æ–­
                            totalDragDistanceX += dragAmount.x
                            totalDragDistanceY += dragAmount.y
                            
                            // [ä¿®å¤] ç­‰å¾…ç´¯ç§¯ä¸€å®šè·ç¦»åå†ç¡®å®šæ‰‹åŠ¿ç±»å‹ï¼Œé¿å…åˆå§‹å™ªå£°å¯¼è‡´è¯¯åˆ¤
                            val minDragThreshold = 20.dp.toPx()
                            val totalDrag = kotlin.math.hypot(totalDragDistanceX, totalDragDistanceY)

                            if (gestureMode == VideoGestureMode.None && totalDrag >= minDragThreshold) {
                                // [ä¿®å¤] ä½¿ç”¨ç´¯ç§¯è·ç¦»åˆ¤æ–­æ–¹å‘ï¼Œè€Œéå•å¸§å¢é‡
                                if (abs(totalDragDistanceX) > abs(totalDragDistanceY)) {
                                    gestureMode = VideoGestureMode.Seek
                                    com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "ğŸ¯ Gesture: Seek (cumDx=$totalDragDistanceX, cumDy=$totalDragDistanceY)")
                                } else {
                                    // æ ¹æ®èµ·å§‹ X åæ ‡åˆ¤æ–­åŒºåŸŸ (å·¦1/3=äº®åº¦, å³1/3=éŸ³é‡, ä¸­é—´1/3=åŠŸèƒ½åŒº)
                                    val width = size.width.toFloat()
                                    // ä½¿ç”¨ onDragStart é”å®šçš„èµ·ç‚¹ Xï¼Œé¿å…æ‹–åŠ¨ä¸­æ¨ªå‘åç§»å¯¼è‡´è¯¯è§¦
                                    val startX = if (dragStartX >= 0f) dragStartX else change.position.x
                                    // åˆ†åŒºè¾¹ç•Œå¢åŠ ç¼“å†²ï¼Œé¿å…ä¸­é—´åŒºåŸŸåœ¨è¾¹ç•Œé™„è¿‘è¢«è¯¯åˆ¤
                                    val boundaryPadding = uiLayoutPolicy.gestureBoundaryPaddingDp.dp.toPx()
                                    val leftZoneEnd = (width / 3f - boundaryPadding).coerceAtLeast(0f)
                                    val rightZoneStart = (width * 2f / 3f + boundaryPadding).coerceAtMost(width)
                                    val isSwipeUp = totalDragDistanceY < -minDragThreshold
                                    
                                    gestureMode = if (!isFullscreen) {
                                        // ç«–å±æ¨¡å¼ï¼šå¯é€‰â€œä¸Šæ»‘è¿›å…¨å±â€ï¼›å…³é—­åæ”¹ä¸ºä¼˜å…ˆäº®åº¦/éŸ³é‡ï¼Œä¸å¼ºåˆ¶è¿›å…¨å±ã€‚
                                        if (portraitSwipeToFullscreenEnabled && isSwipeUp) {
                                            VideoGestureMode.SwipeToFullscreen
                                        } else {
                                            when {
                                                startX < leftZoneEnd -> VideoGestureMode.Brightness
                                                startX > rightZoneStart -> VideoGestureMode.Volume
                                                else -> if (portraitSwipeToFullscreenEnabled) {
                                                    VideoGestureMode.SwipeToFullscreen
                                                } else {
                                                    VideoGestureMode.None
                                                }
                                            }
                                        }
                                    } else {
                                        // æ¨ªå±æ¨¡å¼
                                        // å·¦ä¾§ 1/3: äº®åº¦
                                        // å³ä¾§ 1/3: éŸ³é‡
                                        // ä¸­é—´ 1/3: å¿½ç•¥å‚ç›´æ‰‹åŠ¿ï¼Œé¿å…è¯¯è§¦
                                        when {
                                            startX < leftZoneEnd -> VideoGestureMode.Brightness
                                            startX > rightZoneStart -> VideoGestureMode.Volume
                                            else -> VideoGestureMode.None
                                        }
                                    }

                                    // æ¨ªå±ä¸­é—´ 1/3 çš„å‚ç›´æ‰‹åŠ¿ç›´æ¥å¿½ç•¥ï¼Œé¿å…è¯¯è§¦äº®åº¦/éŸ³é‡
                                    if (isFullscreen && gestureMode == VideoGestureMode.None) {
                                        isGestureVisible = false
                                        com.android.purebilibili.core.util.Logger.d(
                                            "VideoPlayerSection",
                                            "ğŸ¯ Gesture ignored in center zone (fullscreen, startX=$startX, width=$width)"
                                        )
                                        return@detectDragGestures
                                    }

                                    com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "ğŸ¯ Gesture: $gestureMode (startX=$startX, width=$width, isFullscreen=$isFullscreen)")
                                }
                            }

                            when (gestureMode) {
                                VideoGestureMode.SwipeToFullscreen -> {
                                    // ç´¯ç§¯ Y è½´è·ç¦»å·²åœ¨ä¸Šæ–¹å¤„ç†
                                }
                                VideoGestureMode.Seek -> {
                                    // è·ç¦»å·²åœ¨ä¸Šæ–¹ç´¯ç§¯ï¼Œç›´æ¥è®¡ç®—ç›®æ ‡ä½ç½®
                                    val duration = playerState.player.duration.coerceAtLeast(0L)
                                    val seekDelta = resolveHorizontalSeekDeltaMs(
                                        isFullscreen = isFullscreen,
                                        fullscreenSwipeSeekEnabled = fullscreenSwipeSeekEnabled,
                                        totalDragDistanceX = totalDragDistanceX,
                                        containerWidthPx = size.width.toFloat(),
                                        fullscreenSwipeSeekSeconds = fullscreenSwipeSeekSeconds,
                                        gestureSensitivity = gestureSensitivity
                                    )
                                    seekTargetTime = (startPosition + seekDelta).coerceIn(0L, duration)
                                }
                                VideoGestureMode.Brightness -> {
                                    // è·ç¦»å·²åœ¨ä¸Šæ–¹ç´¯ç§¯ï¼Œä½¿ç”¨è´Ÿå€¼å› ä¸ºä¸Šæ»‘æ˜¯è´Ÿ Y
                                    val screenHeight = context.resources.displayMetrics.heightPixels
                                    //  åº”ç”¨çµæ•åº¦
                                    val deltaPercent = -totalDragDistanceY / screenHeight * gestureSensitivity
                                    val newBrightness = (startBrightness + deltaPercent).coerceIn(0f, 1f)
                                    
                                    //  ä¼˜åŒ–ï¼šä»…åœ¨å˜åŒ–è¶…è¿‡é˜ˆå€¼æ—¶æ›´æ–°ï¼ˆå‡å°‘ WindowManager è°ƒç”¨ï¼‰
                                    if (kotlin.math.abs(newBrightness - gesturePercent) > 0.02f) {
                                        getActivity()?.window?.attributes = getActivity()?.window?.attributes?.apply {
                                            screenBrightness = newBrightness
                                        }
                                        gesturePercent = newBrightness
                                    }
                                    //  äº®åº¦å›¾æ ‡ï¼šCupertinoIcons SunMax (iOS SF Symbols é£æ ¼)
                                    gestureIcon = CupertinoIcons.Default.SunMax
                                }
                                VideoGestureMode.Volume -> {
                                    // è·ç¦»å·²åœ¨ä¸Šæ–¹ç´¯ç§¯ï¼Œä½¿ç”¨è´Ÿå€¼å› ä¸ºä¸Šæ»‘æ˜¯è´Ÿ Y
                                    val screenHeight = context.resources.displayMetrics.heightPixels
                                    //  åº”ç”¨çµæ•åº¦
                                    val deltaPercent = -totalDragDistanceY / screenHeight * gestureSensitivity
                                    val newVolPercent = ((startVolume.toFloat() / maxVolume) + deltaPercent).coerceIn(0f, 1f)
                                    val targetVol = (newVolPercent * maxVolume).toInt()
                                    audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, targetVol, 0)
                                    gesturePercent = newVolPercent
                                    //  åŠ¨æ€éŸ³é‡å›¾æ ‡ï¼š3 çº§
                                    gestureIcon = when {
                                        gesturePercent < 0.01f -> CupertinoIcons.Default.SpeakerSlash
                                        gesturePercent < 0.5f -> CupertinoIcons.Default.Speaker
                                        else -> CupertinoIcons.Default.SpeakerWave2
                                    }
                                }
                                else -> {}
                            }
                            }
                        }
                    )
                }
            }
            //  ç‚¹å‡»/åŒå‡»/é•¿æŒ‰æ‰‹åŠ¿åœ¨æ‹–æ‹½ä¹‹åå¤„ç†
            .pointerInput(
                seekForwardSeconds,
                seekBackwardSeconds,
                doubleTapSeekEnabled,
                longPressSpeed,
                isScreenLocked
            ) {
                detectTapGestures(
                    onTap = { 
                        // ğŸ”’ é”å®šæ—¶ç‚¹å‡»åªæ˜¾ç¤ºè§£é”æŒ‰é’®
                        if (isScreenLocked) {
                            showControls = !showControls  // æ˜¾ç¤º/éšè—è§£é”æŒ‰é’®
                        } else {
                            showControls = !showControls
                        }
                    },
                    onLongPress = {
                        // ğŸ”’ é”å®šæ—¶ç¦ç”¨é•¿æŒ‰å€é€Ÿ
                        if (isScreenLocked) return@detectTapGestures
                        //  é•¿æŒ‰å¼€å§‹ï¼šä¿å­˜åŸé€Ÿåº¦å¹¶åº”ç”¨é•¿æŒ‰å€é€Ÿ
                        val player = playerState.player
                        originalSpeed = player.playbackParameters.speed
                        player.setPlaybackSpeed(longPressSpeed)
                        isLongPressing = true
                        longPressSpeedFeedbackVisible = true
                        com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "â© LongPress: speed ${longPressSpeed}x")
                    },
                    onDoubleTap = { offset ->
                        // ğŸ”’ é”å®šæ—¶ç¦ç”¨åŒå‡»
                        if (isScreenLocked) return@detectTapGestures
                        
                        val screenWidth = size.width
                        val player = playerState.player
                        
                        //  [æ–°å¢] è¯»å–åŒå‡»è·³è½¬å¼€å…³
                        // æ³¨æ„ï¼šè¿™é‡Œ directly accessing the state value captured in the closure
                        // We need to ensure we have access to the latest value. 
                        // Since `doubleTapSeekEnabled` is a state, we can read it here.
                        
                        // é€»è¾‘ï¼šå¦‚æœå¼€å¯è·³è½¬ -> ä»¥å‰çš„é€»è¾‘ (ä¸¤ä¾§è·³è½¬ï¼Œä¸­é—´æš‚åœ)
                        //      å¦‚æœå…³é—­è·³è½¬ -> å…¨å±åŒå‡»å‡ä¸ºæš‚åœ/æ’­æ”¾ (è§£å†³é•¿å±æŒ‰ä¸åˆ°æš‚åœçš„é—®é¢˜)
                        
                        if (doubleTapSeekEnabled) {
                            when {
                                // å³ä¾§ 1/3ï¼šå¿«è¿›
                                offset.x > screenWidth * 2 / 3 -> {
                                    val seekMs = seekForwardSeconds * 1000L
                                    val newPos = (player.currentPosition + seekMs).coerceAtMost(player.duration.coerceAtLeast(0L))
                                    player.seekTo(newPos)
                                    danmakuManager.seekTo(newPos)
                                    seekFeedbackText = "+${seekForwardSeconds}s"
                                    seekFeedbackVisible = true
                                    com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "â© DoubleTap right: +${seekForwardSeconds}s")
                                }
                                // å·¦ä¾§ 1/3ï¼šåé€€
                                offset.x < screenWidth / 3 -> {
                                    val seekMs = seekBackwardSeconds * 1000L
                                    val newPos = (player.currentPosition - seekMs).coerceAtLeast(0L)
                                    player.seekTo(newPos)
                                    danmakuManager.seekTo(newPos)
                                    seekFeedbackText = "-${seekBackwardSeconds}s"
                                    seekFeedbackVisible = true
                                    com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "âª DoubleTap left: -${seekBackwardSeconds}s")
                                }
                                // ä¸­é—´ï¼šæš‚åœ/æ’­æ”¾
                                else -> {
                                    player.playWhenReady = !player.playWhenReady
                                    com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "â¯ï¸ DoubleTap center: toggle play/pause")
                                }
                            }
                        } else {
                            // å…³é—­è·³è½¬æ—¶ï¼Œå…¨å±åŒå‡»æš‚åœ/æ’­æ”¾
                            player.playWhenReady = !player.playWhenReady
                            com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "â¯ï¸ DoubleTap (Seek Disabled): toggle play/pause")
                        }
                    },
                    onPress = { offset ->
                        //  ç­‰å¾…æ‰‹æŒ‡æŠ¬èµ·
                        tryAwaitRelease()
                        //  å¦‚æœä¹‹å‰æ˜¯é•¿æŒ‰çŠ¶æ€ï¼Œæ¾å¼€æ—¶æ¢å¤åŸé€Ÿåº¦
                        if (isLongPressing) {
                            playerState.player.setPlaybackSpeed(originalSpeed)
                            isLongPressing = false
                            longPressSpeedFeedbackVisible = false
                            com.android.purebilibili.core.util.Logger.d("VideoPlayerSection", "â¹ï¸ LongPress released: speed ${originalSpeed}x")
                        }
                    }
                )
            }
    ) {
        val scope = rememberCoroutineScope()  //  ç”¨äºè®¾ç½®å¼¹å¹•å¼€å…³
        
        //  å¼¹å¹•å¼€å…³è®¾ç½®
        val danmakuEnabled by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuEnabled(context)
            .collectAsState(initial = true)
        
        //  å¼¹å¹•è®¾ç½®ï¼ˆå…¨å±€æŒä¹…åŒ–ï¼‰
        val danmakuOpacity by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuOpacity(context)
            .collectAsState(initial = 0.85f)
        val danmakuFontScale by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuFontScale(context)
            .collectAsState(initial = 1.0f)
        val danmakuSpeed by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuSpeed(context)
            .collectAsState(initial = 1.0f)
        val danmakuDisplayArea by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuArea(context)
            .collectAsState(initial = 0.5f)
        val danmakuMergeDuplicates by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuMergeDuplicates(context)
            .collectAsState(initial = true)
        val danmakuAllowScroll by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuAllowScroll(context)
            .collectAsState(initial = true)
        val danmakuAllowTop by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuAllowTop(context)
            .collectAsState(initial = true)
        val danmakuAllowBottom by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuAllowBottom(context)
            .collectAsState(initial = true)
        val danmakuAllowColorful by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuAllowColorful(context)
            .collectAsState(initial = true)
        val danmakuAllowSpecial by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuAllowSpecial(context)
            .collectAsState(initial = true)
        val danmakuSmartOcclusion by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuSmartOcclusion(context)
            .collectAsState(initial = false)
        val danmakuBlockRulesRaw by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuBlockRulesRaw(context)
            .collectAsState(initial = "")
        val danmakuBlockRules by com.android.purebilibili.core.store.SettingsManager
            .getDanmakuBlockRules(context)
            .collectAsState(initial = emptyList())
        val faceDetector = remember { createFaceOcclusionDetector() }
        DisposableEffect(faceDetector) {
            onDispose { faceDetector.close() }
        }

        LaunchedEffect(faceDetector) {
            smartOcclusionModuleState = FaceOcclusionModuleState.Checking
            smartOcclusionDownloadProgress = null
            smartOcclusionModuleState = checkFaceOcclusionModuleState(context, faceDetector)
        }
        val canSyncDanmakuCloud = (uiState as? PlayerUiState.Success)?.isLoggedIn == true
        var pendingDanmakuCloudSync by remember {
            mutableStateOf<com.android.purebilibili.data.repository.DanmakuCloudSyncSettings?>(null)
        }

        fun queueDanmakuCloudSync(
            enabled: Boolean = danmakuEnabled,
            allowScroll: Boolean = danmakuAllowScroll,
            allowTop: Boolean = danmakuAllowTop,
            allowBottom: Boolean = danmakuAllowBottom,
            allowColorful: Boolean = danmakuAllowColorful,
            allowSpecial: Boolean = danmakuAllowSpecial,
            opacity: Float = danmakuOpacity,
            displayAreaRatio: Float = danmakuDisplayArea,
            speed: Float = danmakuSpeed,
            fontScale: Float = danmakuFontScale
        ) {
            pendingDanmakuCloudSync = com.android.purebilibili.data.repository.DanmakuCloudSyncSettings(
                enabled = enabled,
                allowScroll = allowScroll,
                allowTop = allowTop,
                allowBottom = allowBottom,
                allowColorful = allowColorful,
                allowSpecial = allowSpecial,
                opacity = opacity,
                displayAreaRatio = displayAreaRatio,
                speed = speed,
                fontScale = fontScale
            )
        }
        
        //  å½“è§†é¢‘/å¼€å…³çŠ¶æ€å˜åŒ–æ—¶æ›´æ–°å¼¹å¹•åŠ è½½ç­–ç•¥
        val cid = (uiState as? PlayerUiState.Success)?.info?.cid ?: 0L
        val aid = (uiState as? PlayerUiState.Success)?.info?.aid ?: 0L
        val danmakuLoadPolicy = remember(cid, danmakuEnabled) {
            resolveVideoPlayerDanmakuLoadPolicy(
                cid = cid,
                danmakuEnabled = danmakuEnabled
            )
        }
        //  ç›‘å¬ player çŠ¶æ€ï¼Œç­‰å¾… duration å¯ç”¨ååŠ è½½å¼¹å¹•
        LaunchedEffect(cid, aid, danmakuEnabled) {
            danmakuManager.isEnabled = danmakuLoadPolicy.shouldEnable
            if (!danmakuLoadPolicy.shouldLoad) {
                return@LaunchedEffect
            }

            //  [ä¿®å¤] ç­‰å¾…æ’­æ”¾å™¨å‡†å¤‡å¥½å¹¶è·å– duration (æœ€å¤šç­‰å¾… 5 ç§’)
            var durationMs = 0L
            var retries = 0
            while (durationMs <= 0 && retries < 50) {
                durationMs = playerState.player.duration.takeIf { it > 0 } ?: 0L
                if (durationMs <= 0) {
                    kotlinx.coroutines.delay(100)
                    retries++
                }
            }

            android.util.Log.d("VideoPlayerSection", "ğŸ¯ Loading danmaku for cid=$cid, aid=$aid, duration=${durationMs}ms (after $retries retries)")
            danmakuManager.loadDanmaku(cid, aid, durationMs)  //  ä¼ å…¥æ—¶é•¿å¯ç”¨ Protobuf API
        }

        //  æ¨ªç«–å±/å°çª—åˆ‡æ¢åï¼Œè‹¥åº”å½“æ’­æ”¾ä½†æœªæ’­æ”¾ï¼Œä¸»åŠ¨æ¢å¤
        LaunchedEffect(isFullscreen, isInPipMode) {
            val player = playerState.player
            if (player.playWhenReady && !player.isPlaying && player.playbackState == Player.STATE_READY) {
                player.play()
            }
        }
        
        //  å¼¹å¹•è®¾ç½®å˜åŒ–æ—¶å®æ—¶åº”ç”¨
        LaunchedEffect(
            danmakuOpacity,
            danmakuFontScale,
            danmakuSpeed,
            danmakuDisplayArea,
            danmakuMergeDuplicates,
            danmakuAllowScroll,
            danmakuAllowTop,
            danmakuAllowBottom,
            danmakuAllowColorful,
            danmakuAllowSpecial,
            danmakuBlockRules,
            danmakuSmartOcclusion
        ) {
            danmakuManager.updateSettings(
                opacity = danmakuOpacity,
                fontScale = danmakuFontScale,
                speed = danmakuSpeed,
                displayArea = danmakuDisplayArea,
                mergeDuplicates = danmakuMergeDuplicates,
                allowScroll = danmakuAllowScroll,
                allowTop = danmakuAllowTop,
                allowBottom = danmakuAllowBottom,
                allowColorful = danmakuAllowColorful,
                allowSpecial = danmakuAllowSpecial,
                blockedRules = danmakuBlockRules,
                // Mask-only mode: keep lane layout fixed, do not move danmaku tracks.
                smartOcclusion = false
            )
        }

        LaunchedEffect(
            playerViewRef,
            faceDetector,
            danmakuEnabled,
            danmakuSmartOcclusion,
            smartOcclusionModuleState,
            isInPipMode,
            isPortraitFullscreen
        ) {
            if (
                !danmakuEnabled ||
                !danmakuSmartOcclusion ||
                smartOcclusionModuleState != FaceOcclusionModuleState.Ready ||
                isInPipMode ||
                isPortraitFullscreen
            ) {
                faceMaskStabilizer.reset()
                faceVisualMasks = emptyList()
                return@LaunchedEffect
            }
            faceMaskStabilizer.reset()

            while (isActive) {
                val view = playerViewRef
                val player = playerState.player
                if (view == null || view.width <= 0 || view.height <= 0 || !player.isPlaying) {
                    kotlinx.coroutines.delay(1200L)
                    continue
                }

                val videoWidth = player.videoSize.width
                val videoHeight = player.videoSize.height
                val sampleWidth = 480
                val sampleHeight = when {
                    videoWidth > 0 && videoHeight > 0 -> (sampleWidth * videoHeight / videoWidth).coerceIn(270, 960)
                    else -> 270
                }

                val detection = withTimeoutOrNull(1_500L) {
                    detectFaceOcclusionRegions(
                        playerView = view,
                        sampleWidth = sampleWidth,
                        sampleHeight = sampleHeight,
                        detector = faceDetector
                    )
                } ?: com.android.purebilibili.feature.video.danmaku.FaceOcclusionDetectionResult(
                    verticalRegions = emptyList(),
                    maskRects = emptyList(),
                    visualMasks = emptyList()
                )
                faceVisualMasks = faceMaskStabilizer.step(detection.visualMasks)
                kotlinx.coroutines.delay(if (detection.visualMasks.isEmpty()) 1300L else 900L)
            }
        }

        // è´¦å·äº‘åŒæ­¥ï¼šç”¨æˆ·ä¿®æ”¹å¼¹å¹•è®¾ç½®åé˜²æŠ–ä¸Šäº‘ï¼Œé¿å…æ»‘æ†æ‹–åŠ¨æ—¶é«˜é¢‘è¯·æ±‚
        LaunchedEffect(pendingDanmakuCloudSync, canSyncDanmakuCloud) {
            val settings = pendingDanmakuCloudSync ?: return@LaunchedEffect
            if (!canSyncDanmakuCloud) return@LaunchedEffect

            kotlinx.coroutines.delay(700)
            val result = com.android.purebilibili.data.repository.DanmakuRepository
                .syncDanmakuCloudConfig(settings)
            if (result.isFailure) {
                android.util.Log.w(
                    "VideoPlayerSection",
                    "Danmaku cloud sync failed: ${result.exceptionOrNull()?.message}"
                )
            }
        }
        
        //  ç»‘å®š Playerï¼ˆä¸åœ¨ onDispose ä¸­é‡Šæ”¾ï¼Œå•ä¾‹ä¿æŒçŠ¶æ€ï¼‰
        DisposableEffect(playerState.player) {
            android.util.Log.d("VideoPlayerSection", " attachPlayer, isFullscreen=$isFullscreen")
            danmakuManager.attachPlayer(playerState.player)
            onDispose {
                // å•ä¾‹æ¨¡å¼ä¸éœ€è¦é‡Šæ”¾
            }
        }
        
        //  [ä¿®å¤] ä½¿ç”¨ LifecycleOwner ç›‘å¬çœŸæ­£çš„ Activity ç”Ÿå‘½å‘¨æœŸ
        // DisposableEffect(Unit) ä¼šåœ¨æ¨ªç«–å±åˆ‡æ¢æ—¶è§¦å‘ï¼Œå¯¼è‡´ player å¼•ç”¨è¢«æ¸…é™¤
        //  [å…³é”®ä¿®å¤] æ·»åŠ  ON_RESUME äº‹ä»¶ï¼Œç¡®ä¿ä»å…¶ä»–è§†é¢‘è¿”å›åé‡æ–°ç»‘å®šå¼¹å¹•æ’­æ”¾å™¨
        val lifecycleOwner = androidx.compose.ui.platform.LocalLifecycleOwner.current
        DisposableEffect(lifecycleOwner, playerState.player) {
            val observer = androidx.lifecycle.LifecycleEventObserver { _, event ->
                when (event) {
                    androidx.lifecycle.Lifecycle.Event.ON_RESUME -> {
                        //  [å…³é”®ä¿®å¤] è¿”å›é¡µé¢æ—¶é‡æ–°ç»‘å®šå¼¹å¹•æ’­æ”¾å™¨
                        // è§£å†³å¯¼èˆªåˆ°å…¶ä»–è§†é¢‘åè¿”å›ï¼Œå¼¹å¹•æš‚åœå¤±æ•ˆçš„é—®é¢˜
                        android.util.Log.d("VideoPlayerSection", " ON_RESUME: Re-attaching danmaku player")
                        danmakuManager.attachPlayer(playerState.player)
                    }
                    androidx.lifecycle.Lifecycle.Event.ON_DESTROY -> {
                        android.util.Log.d("VideoPlayerSection", " ON_DESTROY: Clearing danmaku references")
                        danmakuManager.clearViewReference()
                    }
                    else -> {}
                }
            }
            lifecycleOwner.lifecycle.addObserver(observer)
            onDispose {
                lifecycleOwner.lifecycle.removeObserver(observer)
            }
        }
        
        // 1. PlayerView (åº•å±‚) - key è§¦å‘ graphicsLayer å¼ºåˆ¶æ›´æ–°
        //  [ä¿®å¤] æ·»åŠ  isPortraitFullscreen åˆ° keyï¼Œç¡®ä¿ä»å…¨å±è¿”å›æ—¶é‡å»º PlayerView å¹¶é‡æ–°ç»‘å®š Surface (è§£å†³é»‘å±é—®é¢˜)
        key(isFlippedHorizontal, isFlippedVertical, isPortraitFullscreen) {
            AndroidView(
                factory = { ctx ->
                    val useTextureSurface = shouldUseTextureSurfaceForFlip(
                        isFlippedHorizontal = isFlippedHorizontal,
                        isFlippedVertical = isFlippedVertical
                    )
                    val basePlayerView = if (useTextureSurface) {
                        LayoutInflater.from(ctx)
                            .inflate(com.android.purebilibili.R.layout.view_player_texture, null, false) as PlayerView
                    } else {
                        PlayerView(ctx)
                    }
                    basePlayerView.apply {
                        playerViewRef = this
                        player = if (isPortraitFullscreen) null else playerState.player
                        setKeepContentOnPlayerReset(true)
                        setShutterBackgroundColor(android.graphics.Color.TRANSPARENT)
                        setShowBuffering(PlayerView.SHOW_BUFFERING_NEVER)  // ç¦ç”¨ç³»ç»Ÿç¼“å†²æŒ‡ç¤ºå™¨ï¼Œä½¿ç”¨è‡ªå®šä¹‰iOSé£æ ¼åŠ è½½åŠ¨ç”»
                        useController = false
                        keepScreenOn = true
                        resizeMode = currentAspectRatio.resizeMode
                    }
                },
                update = { playerView ->
                    playerViewRef = playerView
                    playerView.player = if (isPortraitFullscreen) null else playerState.player
                    playerView.resizeMode = currentAspectRatio.resizeMode
                },
                modifier = Modifier
                    .fillMaxSize()
                    .graphicsLayer {
                        //  [æ–°å¢] åº”ç”¨ç¼©æ”¾å’Œå¹³ç§»
                        scaleX = if (isFlippedHorizontal) -scale else scale
                        scaleY = if (isFlippedVertical) -scale else scale
                        translationX = panX
                        translationY = panY
                    }
            )
        }
        

        
    // --- [ä¼˜åŒ–] è§†é¢‘å°é¢é€»è¾‘ ---
    // ä½¿ç”¨ isFirstFrameRendered ç¡®ä¿åªæœ‰åœ¨ç¬¬ä¸€å¸§çœŸæ­£æ¸²æŸ“åæ‰éšè—å°é¢ï¼Œé˜²æ­¢é»‘å±
    var isFirstFrameRendered by remember(bvid) { mutableStateOf(false) }

    DisposableEffect(playerState.player) {
        val listener = object : Player.Listener {
            override fun onRenderedFirstFrame() {
                android.util.Log.d("VideoPlayerCover", "ğŸ¬ onRenderedFirstFrame triggered")
                isFirstFrameRendered = true
            }
            
            // å…¼å®¹æ€§ï¼šåŒæ—¶ä¹Ÿç›‘å¬ Events
            override fun onEvents(player: Player, events: Player.Events) {
                if (events.contains(Player.EVENT_RENDERED_FIRST_FRAME)) {
                    android.util.Log.d("VideoPlayerCover", "ğŸ¬ EVENT_RENDERED_FIRST_FRAME triggered")
                    isFirstFrameRendered = true
                }
            }

            override fun onPlaybackStateChanged(playbackState: Int) {
                if (playbackState == Player.STATE_ENDED) {
                    // æ’­æ”¾ç»“æŸæ˜¾ç¤ºé‡æ’­çŠ¶æ€ï¼ˆé€šå¸¸ç”±ä¸Šå±‚é€»è¾‘å¤„ç†ï¼Œè¿™é‡Œä¸å¤ä½å°é¢ä»¥å…é—ªçƒï¼‰
                    // isFirstFrameRendered = false 
                }
            }
        }
        
        playerState.player.addListener(listener)
        
        // åˆå§‹åŒ–æ£€æŸ¥ï¼šå¦‚æœæ’­æ”¾å™¨å·²ç»å¼€å§‹æ’­æ”¾ä¸”æœ‰è¿›åº¦ï¼Œå¯èƒ½é”™è¿‡äº†äº‹ä»¶
        // [Debug] Log initial check
        if (playerState.player.isPlaying && playerState.player.currentPosition > 0) {
             android.util.Log.d("VideoPlayerCover", "âš ï¸ Initial check: Already playing at ${playerState.player.currentPosition}, hiding cover. (Might be previous video?)")
             isFirstFrameRendered = true
        } else {
             android.util.Log.d("VideoPlayerCover", "âœ… Initial check: Not playing or at start. Keeping cover.")
        }

        onDispose {
            playerState.player.removeListener(listener)
        }
    }
    
    // 4. å°é¢å›¾ (Cover Image) - å§‹ç»ˆåœ¨ç¬¬ä¸€å¸§æ¸²æŸ“å‰æ˜¾ç¤º
    // ä¼˜å…ˆä½¿ç”¨ PlayerUiState.Success ä¸­çš„é«˜æ¸…å°é¢ (pic)ï¼Œå¦åˆ™ä½¿ç”¨ä¼ å…¥çš„ coverUrl
    var rawCoverUrl = if (uiState is PlayerUiState.Success) uiState.info.pic else coverUrl
    
    // [Fix] ä½¿ç”¨ FormatUtils ç»Ÿä¸€å¤„ç† URL (æ”¯æŒæ— åè®®å¤´ URL)
    val currentCoverUrl = FormatUtils.fixImageUrl(rawCoverUrl)
    
    val forceCoverDuringReturnAnimation = shouldForceCoverDuringReturnAnimation(
        forceCoverOnly = forceCoverOnly
    )
    LaunchedEffect(playerState.player, bvid, forceCoverDuringReturnAnimation) {
        if (forceCoverDuringReturnAnimation || isFirstFrameRendered) return@LaunchedEffect
        while (isActive && !isFirstFrameRendered) {
            val player = playerState.player
            if (shouldPromoteFirstFrameByPlaybackFallback(
                    isFirstFrameRendered = isFirstFrameRendered,
                    forceCoverDuringReturnAnimation = forceCoverDuringReturnAnimation,
                    playbackState = player.playbackState,
                    playWhenReady = player.playWhenReady,
                    currentPositionMs = player.currentPosition,
                    videoWidth = player.videoSize.width,
                    videoHeight = player.videoSize.height
                )
            ) {
                android.util.Log.d(
                    "VideoPlayerCover",
                    "ğŸ¬ Fallback promoted first-frame state by playback progress"
                )
                isFirstFrameRendered = true
                break
            }
            delay(120L)
        }
    }
    val showCover = shouldShowCoverImage(
        isFirstFrameRendered = isFirstFrameRendered,
        forceCoverDuringReturnAnimation = forceCoverDuringReturnAnimation
    )
    val disableCoverFadeAnimation = shouldDisableCoverFadeAnimation(forceCoverDuringReturnAnimation)
    
    // [Debug] Logging
    LaunchedEffect(showCover, currentCoverUrl, isFirstFrameRendered, uiState) {
        android.util.Log.d("VideoPlayerCover", "ğŸ” Check: bvid=$bvid, showCover=$showCover, isFirstFrame=$isFirstFrameRendered, coverUrl=$coverUrl, finalUrl=$currentCoverUrl")
    }

    AnimatedVisibility(
        visible = showCover && currentCoverUrl.isNotEmpty(),
        enter = if (disableCoverFadeAnimation) EnterTransition.None else fadeIn(animationSpec = tween(200)),
        exit = if (disableCoverFadeAnimation) ExitTransition.None else fadeOut(animationSpec = tween(300)),
        modifier = Modifier.zIndex(100f) // è¿”å›ä¸­å¼ºåˆ¶å°é¢æ—¶ï¼Œç¡®ä¿å°é¢å‹ä½æ‰€æœ‰æ’­æ”¾å™¨å±‚
    ) {
        AsyncImage(
            model = coil.request.ImageRequest.Builder(LocalContext.current)
                .data(currentCoverUrl)
                // [å…³é”®] å°è¯•ä½¿ç”¨é¦–é¡µå¡ç‰‡çš„ç¼“å­˜ Key ä½œä¸ºå ä½ï¼Œå®ç°æ— ç¼è¿‡æ¸¡
                // å‡è®¾é¦–é¡µå¡ç‰‡ä½¿ç”¨çš„æ˜¯æ™®é€šæ¨¡å¼ ("n")
                .placeholderMemoryCacheKey("cover_${bvid}_n")
                .listener(
                    onStart = { android.util.Log.d("VideoPlayerCover", "ğŸ–¼ï¸ Image loading started: $currentCoverUrl") },
                    onSuccess = { _, _ -> android.util.Log.d("VideoPlayerCover", "ğŸ–¼ï¸ Image loaded successfully") },
                    onError = { _, result -> android.util.Log.e("VideoPlayerCover", "âŒ Image load failed: ${result.throwable.message}", result.throwable) }
                )
                .crossfade(true)
                .build(),
            contentDescription = null,
            contentScale = ContentScale.Crop, // [ä¿®æ”¹] ä½¿ç”¨ Crop å¡«æ»¡å±å¹•
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black)
        )
    }

    // 2. DanmakuView (ä½¿ç”¨ ByteDance DanmakuRenderEngine - è¦†ç›–åœ¨ PlayerView ä¸Šæ–¹)
    android.util.Log.d("VideoPlayerSection", "ğŸ” DanmakuView check: isInPipMode=$isInPipMode, danmakuEnabled=$danmakuEnabled")
        if (!isInPipMode && danmakuEnabled && !isPortraitFullscreen) {
            android.util.Log.d("VideoPlayerSection", " Conditions met, creating DanmakuView...")
            //  è®¡ç®—çŠ¶æ€æ é«˜åº¦
            val statusBarHeightPx = remember(context) {
                val resourceId = context.resources.getIdentifier(
                    "status_bar_height", "dimen", "android"
                )
                if (resourceId > 0) {
                    context.resources.getDimensionPixelSize(resourceId)
                } else {
                    (24 * context.resources.displayMetrics.density).toInt()
                }
            }
            
            //  éå…¨å±æ—¶çš„é¡¶éƒ¨åç§»é‡
            val topOffset = if (isFullscreen) 0 else statusBarHeightPx + 20
            
            //  [ä¿®å¤] ç§»é™¤ key(isFullscreen)ï¼Œé¿å…æ¨ªç«–å±åˆ‡æ¢æ—¶é‡å»º DanmakuView å¯¼è‡´å¼¹å¹•æ¶ˆå¤±
            // ä½¿ç”¨ remember ä¿å­˜ DanmakuView å¼•ç”¨ï¼Œåœ¨ update å›è°ƒä¸­å¤„ç†å°ºå¯¸å˜åŒ–
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .then(
                        if (!isFullscreen) {
                            Modifier.padding(top = with(LocalContext.current.resources.displayMetrics) {
                                (topOffset / density).dp
                            })
                        } else Modifier
                    )
                    .clipToBounds()
            ) {
                AndroidView(
                    factory = { ctx ->
                        FaceOcclusionDanmakuContainer(ctx).apply {
                            setMasks(faceVisualMasks)
                            setVideoViewport(
                                videoWidth = playerState.player.videoSize.width,
                                videoHeight = playerState.player.videoSize.height,
                                resizeMode = currentAspectRatio.resizeMode
                            )
                            danmakuManager.attachView(danmakuView())
                            android.util.Log.d("VideoPlayerSection", " DanmakuView (RenderEngine) created, isFullscreen=$isFullscreen")
                        }
                    },
                    update = { container ->
                        container.setMasks(faceVisualMasks)
                        container.setVideoViewport(
                            videoWidth = playerState.player.videoSize.width,
                            videoHeight = playerState.player.videoSize.height,
                            resizeMode = currentAspectRatio.resizeMode
                        )
                        val view = container.danmakuView()
                        //  [å…³é”®] æ¨ªç«–å±åˆ‡æ¢åè§†å›¾å°ºå¯¸å˜åŒ–æ—¶ï¼Œé‡æ–° attachView ç¡®ä¿å¼¹å¹•æ­£ç¡®æ˜¾ç¤º
                        android.util.Log.d("VideoPlayerSection", " DanmakuView update: size=${view.width}x${view.height}, isFullscreen=$isFullscreen")
                        // åªæœ‰å½“è§†å›¾æœ‰æœ‰æ•ˆå°ºå¯¸æ—¶æ‰ re-attach
                        if (view.width > 0 && view.height > 0) {
                            val sizeTag = "${view.width}x${view.height}"
                            if (view.tag != sizeTag) {
                                view.tag = sizeTag
                                danmakuManager.attachView(view)
                            }
                        }
                    },
                    modifier = Modifier.fillMaxSize()
                )
            }
        }
        
        // 3. é«˜çº§å¼¹å¹•å±‚ (Mode 7) - è¦†ç›–åœ¨æ ‡å‡†å¼¹å¹•ä¸Šæ–¹
        val advancedDanmakuList by danmakuManager.advancedDanmakuFlow.collectAsState()
        
        if (!isInPipMode && danmakuEnabled && advancedDanmakuList.isNotEmpty()) {
             Box(
                modifier = Modifier
                    .fillMaxSize()
                    .clipToBounds()
            ) {
                com.android.purebilibili.feature.video.ui.overlay.AdvancedDanmakuOverlay(
                    danmakuList = advancedDanmakuList,
                    player = playerState.player,
                    modifier = Modifier.fillMaxSize()
                )
            }
        }

        // 4. Bç«™å­—å¹•å åŠ å±‚ï¼ˆæ”¯æŒä¸­è‹±åŒè¯­ï¼‰
        val subtitleFeatureEnabled = isSubtitleFeatureEnabledForUser()
        val subtitlePrimaryAvailable = remember(uiState, subtitleFeatureEnabled) {
            if (!subtitleFeatureEnabled) return@remember false
            val success = uiState as? PlayerUiState.Success ?: return@remember false
            success.subtitlePrimaryCues.isNotEmpty()
        }
        val subtitleSecondaryAvailable = remember(uiState, subtitleFeatureEnabled) {
            if (!subtitleFeatureEnabled) return@remember false
            val success = uiState as? PlayerUiState.Success ?: return@remember false
            success.subtitleSecondaryCues.isNotEmpty()
        }
        val subtitleTrackAvailable = subtitlePrimaryAvailable || subtitleSecondaryAvailable
        val subtitleToggleKey = remember(uiState, bvid) {
            val success = uiState as? PlayerUiState.Success
            if (success == null) {
                "no-subtitle"
            } else {
                "${bvid}_${success.info.cid}_${success.subtitlePrimaryLanguage}_${success.subtitleSecondaryLanguage}"
            }
        }
        var subtitleDisplayModePreference by rememberSaveable("${subtitleToggleKey}_mode") {
            mutableStateOf(
                if (subtitleFeatureEnabled) {
                    resolveDefaultSubtitleDisplayMode(
                        hasPrimaryTrack = subtitlePrimaryAvailable,
                        hasSecondaryTrack = subtitleSecondaryAvailable
                    )
                } else {
                    SubtitleDisplayMode.OFF
                }
            )
        }
        var subtitleLargeTextByUser by rememberSaveable("${subtitleToggleKey}_large") {
            mutableStateOf(false)
        }
        val subtitleDisplayMode = remember(
            subtitleFeatureEnabled,
            subtitleDisplayModePreference,
            subtitlePrimaryAvailable,
            subtitleSecondaryAvailable
        ) {
            if (!subtitleFeatureEnabled) {
                SubtitleDisplayMode.OFF
            } else {
                normalizeSubtitleDisplayMode(
                    preferredMode = subtitleDisplayModePreference,
                    hasPrimaryTrack = subtitlePrimaryAvailable,
                    hasSecondaryTrack = subtitleSecondaryAvailable
                )
            }
        }
        val subtitleOverlayEnabled = subtitleFeatureEnabled && subtitleDisplayMode != SubtitleDisplayMode.OFF
        val subtitlePrimaryLabel = remember(uiState) {
            val success = uiState as? PlayerUiState.Success
            resolveSubtitleLanguageLabel(
                languageCode = success?.subtitlePrimaryLanguage,
                fallbackLabel = "ä¸­æ–‡"
            )
        }
        val subtitleSecondaryLabel = remember(uiState) {
            val success = uiState as? PlayerUiState.Success
            resolveSubtitleLanguageLabel(
                languageCode = success?.subtitleSecondaryLanguage,
                fallbackLabel = "è‹±æ–‡"
            )
        }

        val subtitlePositionMs by produceState(initialValue = 0L, key1 = playerState.player, key2 = uiState) {
            while (isActive) {
                value = playerState.player.currentPosition.coerceAtLeast(0L)
                delay(if (playerState.player.isPlaying) 120L else 260L)
            }
        }
        val subtitlePrimaryText = remember(uiState, subtitleFeatureEnabled, subtitlePositionMs, subtitleDisplayMode) {
            if (!subtitleFeatureEnabled) return@remember null
            val success = uiState as? PlayerUiState.Success ?: return@remember null
            if (!shouldRenderPrimarySubtitle(subtitleDisplayMode)) return@remember null
            resolveSubtitleTextAt(success.subtitlePrimaryCues, subtitlePositionMs)
        }
        val subtitleSecondaryText = remember(uiState, subtitleFeatureEnabled, subtitlePositionMs, subtitleDisplayMode) {
            if (!subtitleFeatureEnabled) return@remember null
            val success = uiState as? PlayerUiState.Success ?: return@remember null
            if (!shouldRenderSecondarySubtitle(subtitleDisplayMode)) return@remember null
            resolveSubtitleTextAt(success.subtitleSecondaryCues, subtitlePositionMs)
        }
        if (!isInPipMode &&
            !isAudioOnly &&
            uiState is PlayerUiState.Success &&
            !suppressSubtitleOverlay &&
            subtitleOverlayEnabled &&
            (subtitlePrimaryText != null || subtitleSecondaryText != null)
        ) {
            val subtitleBottomPadding = when {
                showControls && isFullscreen -> 132.dp
                showControls -> 108.dp
                else -> 42.dp
            }
            Column(
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .fillMaxWidth(0.9f)
                    .padding(horizontal = 10.dp)
                    .padding(bottom = subtitleBottomPadding)
                    .background(
                        Color.Black.copy(alpha = 0.42f),
                        RoundedCornerShape(10.dp)
                    )
                    .padding(horizontal = 12.dp, vertical = 8.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                val showPrimaryLine = !subtitlePrimaryText.isNullOrBlank()
                val showSecondaryLine = !subtitleSecondaryText.isNullOrBlank()
                val secondaryAsPrimaryLine = showSecondaryLine && !showPrimaryLine
                if (!subtitleSecondaryText.isNullOrBlank()) {
                    Text(
                        text = subtitleSecondaryText,
                        color = Color.White.copy(alpha = 0.88f),
                        fontSize = when {
                            secondaryAsPrimaryLine && subtitleLargeTextByUser -> 18.sp
                            secondaryAsPrimaryLine -> 16.sp
                            subtitleLargeTextByUser -> 16.sp
                            else -> 14.sp
                        },
                        fontWeight = if (secondaryAsPrimaryLine) FontWeight.SemiBold else FontWeight.Normal,
                        maxLines = 2,
                        textAlign = TextAlign.Center
                    )
                }
                if (!subtitlePrimaryText.isNullOrBlank()) {
                    Text(
                        text = subtitlePrimaryText,
                        color = Color.White,
                        fontSize = if (subtitleLargeTextByUser) 18.sp else 16.sp,
                        fontWeight = FontWeight.SemiBold,
                        maxLines = 2,
                        textAlign = TextAlign.Center
                    )
                }
            }
        }

        // ğŸ–¼ï¸ [ä¿®å¤] æ‰‹åŠ¿æŒ‡ç¤ºå™¨ï¼šä»…åœ¨äº®åº¦/éŸ³é‡/Seek æ¨¡å¼æ˜¾ç¤ºï¼Œé¿å…ä¸Šæ»‘å…¨å±æ—¶è¯¯æ˜¾ç¤ºäº®åº¦å›¾æ ‡
        val shouldShowGestureIndicator = isGestureVisible &&
            !isInPipMode &&
            (gestureMode == VideoGestureMode.Seek ||
                gestureMode == VideoGestureMode.Brightness ||
                gestureMode == VideoGestureMode.Volume)

        if (shouldShowGestureIndicator) {
            if (gestureMode == VideoGestureMode.Seek) {
                // ğŸ–¼ï¸ Seek æ¨¡å¼ï¼šæ˜¾ç¤ºå¸¦ç¼©ç•¥å›¾çš„é¢„è§ˆæ°”æ³¡
                Box(
                    modifier = Modifier.align(Alignment.Center),
                    contentAlignment = Alignment.Center
                ) {
                    if (videoshotData != null && videoshotData.isValid) {
                        // ğŸ–¼ï¸ æœ‰ç¼©ç•¥å›¾ï¼šæ˜¾ç¤ºå®Œæ•´é¢„è§ˆ
                        com.android.purebilibili.feature.video.ui.components.SeekPreviewBubble(
                            videoshotData = videoshotData,
                            targetPositionMs = seekTargetTime,
                            currentPositionMs = startPosition,
                            durationMs = playerState.player.duration,
                            offsetX = 80f,  // å±…ä¸­åç§»ï¼ˆæ°”æ³¡å®½åº¦çš„ä¸€åŠï¼‰
                            containerWidth = 160f  // ä¸æ°”æ³¡å®½åº¦åŒ¹é…
                        )
                    } else {
                        // æ— ç¼©ç•¥å›¾ï¼šä½¿ç”¨åŸæœ‰æ ·å¼
                        Box(
                            modifier = Modifier
                                .size(uiLayoutPolicy.gestureOverlaySizeDp.dp)
                                .background(Color.Black.copy(0.7f), RoundedCornerShape(16.dp)),
                            contentAlignment = Alignment.Center
                        ) {
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                val durationSeconds = (playerState.player.duration / 1000).coerceAtLeast(1)
                                val targetSeconds = (seekTargetTime / 1000).toInt()

                                Text(
                                    text = "${FormatUtils.formatDuration(targetSeconds)} / ${FormatUtils.formatDuration(durationSeconds.toInt())}",
                                    color = Color.White,
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold
                                )

                                val deltaSeconds = (seekTargetTime - startPosition) / 1000
                                val sign = if (deltaSeconds > 0) "+" else ""
                                if (deltaSeconds != 0L) {
                                    Text(
                                        text = "($sign${deltaSeconds}s)",
                                        color = if (deltaSeconds > 0) com.android.purebilibili.core.theme.iOSGreen else com.android.purebilibili.core.theme.iOSRed,
                                        style = MaterialTheme.typography.bodySmall
                                    )
                                }
                            }
                        }
                    }
                }
            } else {
                // äº®åº¦/éŸ³é‡æ¨¡å¼ï¼šä¿æŒåŸæœ‰æ ·å¼
                Box(
                    modifier = Modifier
                        .align(Alignment.Center)
                        .size(uiLayoutPolicy.gestureOverlaySizeDp.dp)
                        .background(Color.Black.copy(0.7f), RoundedCornerShape(16.dp)),
                    contentAlignment = Alignment.Center
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(
                            imageVector = gestureIcon ?: CupertinoIcons.Default.SunMax,
                            contentDescription = null,
                            tint = Color.White,
                            modifier = Modifier.size(uiLayoutPolicy.gestureIconSizeDp.dp)
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "${(gesturePercent * 100).toInt()}%",
                            color = Color.White,
                            style = MaterialTheme.typography.titleMedium.copy(
                                fontWeight = FontWeight.Bold,
                                fontSize = 18.sp
                            )
                        )
                    }
                }
            }
        }
        
        //  [æ–°å¢] åŒå‡»è·³è½¬è§†è§‰åé¦ˆ (Â±Ns æç¤º)
        LaunchedEffect(seekFeedbackVisible) {
            if (seekFeedbackVisible) {
                kotlinx.coroutines.delay(800)
                seekFeedbackVisible = false
            }
        }
        
        AnimatedVisibility(
            visible = seekFeedbackVisible && !isInPipMode,
            modifier = Modifier.align(Alignment.Center),
            enter = scaleIn(initialScale = 0.5f) + fadeIn(),
            exit = scaleOut(targetScale = 0.8f) + fadeOut()
        ) {
            Box(
                modifier = Modifier
                    .size(uiLayoutPolicy.seekFeedbackSizeDp.dp)
                    .background(Color.Black.copy(0.75f), RoundedCornerShape(20.dp)),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = seekFeedbackText ?: "",
                    color = if (seekFeedbackText?.startsWith("+") == true) com.android.purebilibili.core.theme.iOSGreen else com.android.purebilibili.core.theme.iOSRed,
                    style = MaterialTheme.typography.headlineMedium.copy(
                        fontWeight = FontWeight.Bold
                    )
                )
            }
        }

        //  [æ–°å¢] ç¼©æ”¾è¿˜åŸæŒ‰é’® (ä»…åœ¨æ”¾å¤§æ—¶æ˜¾ç¤º)
        AnimatedVisibility(
            visible = scale > 1.05f && !isInPipMode,
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(bottom = uiLayoutPolicy.restoreButtonBottomOffsetDp.dp), // é¿å¼€åº•éƒ¨è¿›åº¦æ¡ä½ç½®
            enter = fadeIn() + scaleIn(),
            exit = fadeOut() + scaleOut()
        ) {
            Button(
                onClick = {
                    scale = 1f
                    panX = 0f
                    panY = 0f
                    // showControls = true // å¯é€‰ï¼šè¿˜åŸåæ˜¾ç¤ºæ§åˆ¶æ 
                },
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color.Black.copy(alpha = 0.6f),
                    contentColor = Color.White
                ),
                contentPadding = PaddingValues(
                    horizontal = uiLayoutPolicy.restoreButtonHorizontalPaddingDp.dp,
                    vertical = uiLayoutPolicy.restoreButtonVerticalPaddingDp.dp
                ),
                shape = RoundedCornerShape(24.dp)
            ) {
                Icon(
                    imageVector = Icons.Filled.Refresh,
                    contentDescription = "è¿˜åŸç”»é¢",
                    modifier = Modifier.size(uiLayoutPolicy.restoreButtonIconSizeDp.dp)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "è¿˜åŸç”»é¢",
                    style = MaterialTheme.typography.labelLarge.copy(fontWeight = FontWeight.Bold)
                )
            }
        }
        
        //  é•¿æŒ‰å€é€Ÿæç¤ºï¼ˆç®€æ´ç‰ˆï¼Œ1ç§’åæ¶ˆå¤±ï¼‰
        LaunchedEffect(longPressSpeedFeedbackVisible) {
            if (longPressSpeedFeedbackVisible) {
                kotlinx.coroutines.delay(1000)
                longPressSpeedFeedbackVisible = false
            }
        }
        
        AnimatedVisibility(
            visible = longPressSpeedFeedbackVisible && !isInPipMode,
            modifier = Modifier.align(Alignment.Center),
            enter = scaleIn(initialScale = 0.5f) + fadeIn(),
            exit = scaleOut(targetScale = 0.8f) + fadeOut()
        ) {
            Box(
                modifier = Modifier
                    .background(Color.Black.copy(0.75f), RoundedCornerShape(16.dp))
                    .padding(
                        horizontal = uiLayoutPolicy.longPressBadgeHorizontalPaddingDp.dp,
                        vertical = uiLayoutPolicy.longPressBadgeVerticalPaddingDp.dp
                    )
            ) {
                Text(
                    text = "${longPressSpeed}x",
                    color = Color.White,
                    style = MaterialTheme.typography.titleLarge.copy(
                        fontWeight = FontWeight.Bold
                    )
                )
            }
        }

        if (uiState is PlayerUiState.Success && !isInPipMode) {
            val currentPageIndex = uiState.info.pages.indexOfFirst { it.cid == uiState.info.cid }.coerceAtLeast(0)
            VideoPlayerOverlay(
                player = playerState.player,
                title = uiState.info.title,
                // [ä¿®å¤] ç«–å±å…¨å±æ¨¡å¼ä¸‹éšè—åº•éƒ¨ Overlayï¼Œé¿å…è¿›åº¦çŠ¶æ€å†²çª
                isVisible = showControls && !isPortraitFullscreen,
                onToggleVisible = { showControls = !showControls },
                isFullscreen = isFullscreen,
                currentQualityLabel = uiState.qualityLabels.getOrNull(uiState.qualityIds.indexOf(uiState.currentQuality)) ?: "è‡ªåŠ¨",
                qualityLabels = uiState.qualityLabels,
                qualityIds = uiState.qualityIds,
                onQualitySelected = { index ->
                    val id = uiState.qualityIds.getOrNull(index) ?: 0
                    onQualityChange(id, playerState.player.currentPosition)
                },
                onBack = onBack,
                onToggleFullscreen = onToggleFullscreen,
                
                // ğŸ”’ [æ–°å¢] å±å¹•é”å®š
                isScreenLocked = isScreenLocked,
                onLockToggle = { isScreenLocked = !isScreenLocked },
                //  [å…³é”®] ä¼ å…¥è®¾ç½®çŠ¶æ€å’ŒçœŸå®åˆ†è¾¨ç‡å­—ç¬¦ä¸²
                showStats = showStats,
                realResolution = realResolution,
                //  [æ–°å¢] ä¼ å…¥æ¸…æ™°åº¦åˆ‡æ¢çŠ¶æ€å’Œä¼šå‘˜çŠ¶æ€
                isQualitySwitching = uiState.isQualitySwitching,
                isBuffering = isBuffering,  // ç¼“å†²çŠ¶æ€
                isLoggedIn = uiState.isLoggedIn,
                isVip = uiState.isVip,
                //  [æ–°å¢] å¼¹å¹•å¼€å…³å’Œè®¾ç½®
                danmakuEnabled = danmakuEnabled,
                onDanmakuToggle = {
                    val newState = !danmakuEnabled
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuEnabled(context, newState)
                    }
                    queueDanmakuCloudSync(enabled = newState)
                    //  è®°å½•å¼¹å¹•å¼€å…³äº‹ä»¶
                    com.android.purebilibili.core.util.AnalyticsHelper.logDanmakuToggle(newState)
                },
                onDanmakuInputClick = onDanmakuInputClick,
                danmakuOpacity = danmakuOpacity,
                danmakuFontScale = danmakuFontScale,
                danmakuSpeed = danmakuSpeed,
                danmakuDisplayArea = danmakuDisplayArea,
                danmakuMergeDuplicates = danmakuMergeDuplicates,
                danmakuAllowScroll = danmakuAllowScroll,
                danmakuAllowTop = danmakuAllowTop,
                danmakuAllowBottom = danmakuAllowBottom,
                danmakuAllowColorful = danmakuAllowColorful,
                danmakuAllowSpecial = danmakuAllowSpecial,
                danmakuBlockRulesRaw = danmakuBlockRulesRaw,
                danmakuSmartOcclusion = danmakuSmartOcclusion,
                onDanmakuOpacityChange = { value ->
                    danmakuManager.opacity = value
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuOpacity(context, value)
                    }
                    queueDanmakuCloudSync(opacity = value)
                },
                onDanmakuFontScaleChange = { value ->
                    danmakuManager.fontScale = value
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuFontScale(context, value)
                    }
                    queueDanmakuCloudSync(fontScale = value)
                },
                onDanmakuSpeedChange = { value ->
                    danmakuManager.speedFactor = value
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuSpeed(context, value)
                    }
                    queueDanmakuCloudSync(speed = value)
                },
                onDanmakuDisplayAreaChange = { value ->
                    danmakuManager.displayArea = value
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuArea(context, value)
                    }
                    queueDanmakuCloudSync(displayAreaRatio = value)
                },
                onDanmakuMergeDuplicatesChange = { value ->
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuMergeDuplicates(context, value)
                    }
                },
                onDanmakuAllowScrollChange = { value ->
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuAllowScroll(context, value)
                    }
                    queueDanmakuCloudSync(allowScroll = value)
                },
                onDanmakuAllowTopChange = { value ->
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuAllowTop(context, value)
                    }
                    queueDanmakuCloudSync(allowTop = value)
                },
                onDanmakuAllowBottomChange = { value ->
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuAllowBottom(context, value)
                    }
                    queueDanmakuCloudSync(allowBottom = value)
                },
                onDanmakuAllowColorfulChange = { value ->
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuAllowColorful(context, value)
                    }
                    queueDanmakuCloudSync(allowColorful = value)
                },
                onDanmakuAllowSpecialChange = { value ->
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuAllowSpecial(context, value)
                    }
                    queueDanmakuCloudSync(allowSpecial = value)
                },
                onDanmakuSmartOcclusionChange = { value ->
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuSmartOcclusion(context, value)
                    }
                },
                onDanmakuBlockRulesRawChange = { value ->
                    scope.launch {
                        com.android.purebilibili.core.store.SettingsManager.setDanmakuBlockRulesRaw(context, value)
                    }
                },
                smartOcclusionModuleState = smartOcclusionModuleState,
                smartOcclusionDownloadProgress = smartOcclusionDownloadProgress,
                onDanmakuSmartOcclusionDownloadClick = {
                    if (smartOcclusionModuleState != FaceOcclusionModuleState.Downloading) {
                        scope.launch {
                            smartOcclusionModuleState = FaceOcclusionModuleState.Downloading
                            smartOcclusionDownloadProgress = 0
                            smartOcclusionModuleState = installFaceOcclusionModule(
                                context = context,
                                detector = faceDetector,
                                onProgress = { progress ->
                                    smartOcclusionDownloadProgress = progress
                                }
                            )
                            if (smartOcclusionModuleState != FaceOcclusionModuleState.Downloading) {
                                smartOcclusionDownloadProgress = null
                            }
                        }
                    }
                },
                //  è§†é¢‘æ¯”ä¾‹è°ƒèŠ‚

                currentAspectRatio = currentAspectRatio,
                onAspectRatioChange = { currentAspectRatio = it },
                // ğŸ•º [æ–°å¢] åˆ†äº«åŠŸèƒ½
                bvid = bvid,
                cid = uiState.info.cid,
                videoOwnerName = uiState.info.owner.name,
                videoOwnerFace = uiState.info.owner.face,
                videoDuration = playerState.player.duration.toInt().coerceAtLeast(0),
                videoTitle = uiState.info.title,
                currentAid = uiState.info.aid,
                currentQuality = uiState.currentQuality,
                currentVideoUrl = uiState.playUrl,
                currentAudioUrl = uiState.audioUrl ?: "",
                coverUrl = uiState.info.pic,
                //  [æ–°å¢] è§†é¢‘è®¾ç½®é¢æ¿å›è°ƒ
                onReloadVideo = onReloadVideo,
                isFlippedHorizontal = isFlippedHorizontal,
                isFlippedVertical = isFlippedVertical,
                onFlipHorizontal = { isFlippedHorizontal = !isFlippedHorizontal },
                onFlipVertical = { isFlippedVertical = !isFlippedVertical },
                //  [æ–°å¢] ç”»è´¨åˆ‡æ¢ï¼ˆç”¨äºè®¾ç½®é¢æ¿ï¼‰
                onQualityChange = { qid, pos ->
                    onQualityChange(qid, playerState.player.currentPosition)
                },
                //  [æ–°å¢] CDN çº¿è·¯åˆ‡æ¢
                currentCdnIndex = currentCdnIndex,
                cdnCount = cdnCount,
                onSwitchCdn = onSwitchCdn,
                onSwitchCdnTo = onSwitchCdnTo,
                
                //  [æ–°å¢] éŸ³é¢‘æ¨¡å¼
                isAudioOnly = isAudioOnly,
                onAudioOnlyToggle = onAudioOnlyToggle,
                subtitleControlState = SubtitleControlUiState(
                    trackAvailable = subtitleFeatureEnabled && subtitleTrackAvailable,
                    primaryAvailable = subtitleFeatureEnabled && subtitlePrimaryAvailable,
                    secondaryAvailable = subtitleFeatureEnabled && subtitleSecondaryAvailable,
                    enabled = subtitleFeatureEnabled && subtitleOverlayEnabled,
                    displayMode = if (subtitleFeatureEnabled) subtitleDisplayMode else SubtitleDisplayMode.OFF,
                    primaryLabel = subtitlePrimaryLabel,
                    secondaryLabel = subtitleSecondaryLabel,
                    largeTextEnabled = subtitleLargeTextByUser
                ),
                subtitleControlCallbacks = SubtitleControlCallbacks(
                    onDisplayModeChange = { mode ->
                        com.android.purebilibili.core.util.Logger.d(
                            "VideoPlayerSection",
                            "å­—å¹•æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢: mode=$mode"
                        )
                        subtitleDisplayModePreference = mode
                    },
                    onEnabledChange = { enabled ->
                        com.android.purebilibili.core.util.Logger.d(
                            "VideoPlayerSection",
                            "å­—å¹•æ€»å¼€å…³åˆ‡æ¢: enabled=$enabled"
                        )
                        subtitleDisplayModePreference = if (enabled) {
                            resolveDefaultSubtitleDisplayMode(
                                hasPrimaryTrack = subtitlePrimaryAvailable,
                                hasSecondaryTrack = subtitleSecondaryAvailable
                            )
                        } else {
                            SubtitleDisplayMode.OFF
                        }
                    },
                    onLargeTextChange = { enabled ->
                        com.android.purebilibili.core.util.Logger.d(
                            "VideoPlayerSection",
                            "å­—å¹•å¤§å­—å·åˆ‡æ¢: enabled=$enabled"
                        )
                        subtitleLargeTextByUser = enabled
                    }
                ),
                
                //  [æ–°å¢] å®šæ—¶å…³é—­
                sleepTimerMinutes = sleepTimerMinutes,
                onSleepTimerChange = onSleepTimerChange,
                
                // ğŸ–¼ï¸ [æ–°å¢] è§†é¢‘é¢„è§ˆå›¾æ•°æ®
                videoshotData = videoshotData,
                
                // ğŸ“– [æ–°å¢] è§†é¢‘ç« èŠ‚æ•°æ®
                viewPoints = viewPoints,
                
                // ğŸ“± [æ–°å¢] ç«–å±å…¨å±æ¨¡å¼
                isVerticalVideo = isVerticalVideo,
                onPortraitFullscreen = onPortraitFullscreen,
                // ğŸ“² [æ–°å¢] å°çª—æ¨¡å¼
                // ğŸ“² [æ–°å¢] å°çª—æ¨¡å¼
                onPipClick = onPipClick,
                //  [æ–°å¢] æ‹–åŠ¨è¿›åº¦æ¡å¼€å§‹æ—¶æ¸…é™¤å¼¹å¹•
                onSeekStart = { danmakuManager.clear() },
                //  [åŠ å›º] æ˜¾å¼åŒæ­¥å¼¹å¹•åˆ°æ–°è¿›åº¦ï¼Œé¿å…æŸäº›è®¾å¤‡ seek å›è°ƒæ—¶æœºå·®å¯¼è‡´çŸ­æš‚ä¸åŒæ­¥
                onSeekTo = { position ->
                    playerState.player.seekTo(position)
                    danmakuManager.seekTo(position)
                },
                // [New] Codec & Audio
                currentCodec = currentCodec,
                onCodecChange = onCodecChange,
                currentSecondCodec = currentSecondCodec,
                onSecondCodecChange = onSecondCodecChange,
                currentAudioQuality = currentAudioQuality,
                onAudioQualityChange = onAudioQualityChange,
                // [New] AI Audio
                aiAudioInfo = uiState.aiAudio,
                currentAudioLang = uiState.currentAudioLang,
                onAudioLangChange = onAudioLangChange,
                // ğŸ‘€ [æ–°å¢] åœ¨çº¿è§‚çœ‹äººæ•°
                onlineCount = uiState.onlineCount,
                // [New]
                onSaveCover = onSaveCover,
                onCaptureScreenshot = {
                    val playerView = playerViewRef
                    if (playerView == null) {
                        Toast.makeText(context, "æˆªå›¾å¤±è´¥ï¼šæ’­æ”¾å™¨æœªå°±ç»ª", Toast.LENGTH_SHORT).show()
                    } else {
                        scope.launch {
                            val success = captureAndSaveVideoScreenshot(
                                context = context,
                                playerView = playerView,
                                videoWidth = videoSizeState.first,
                                videoHeight = videoSizeState.second,
                                videoTitle = uiState.info.title,
                            )
                            Toast.makeText(
                                context,
                                if (success) "æˆªå›¾å·²ä¿å­˜åˆ°ç›¸å†Œï¼ˆPNGï¼‰" else "æˆªå›¾å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•",
                                Toast.LENGTH_SHORT
                            ).show()
                        }
                    }
                },
                onDownloadAudio = onDownloadAudio,
                // ğŸ” [æ–°å¢] æ’­æ”¾æ¨¡å¼
                currentPlayMode = currentPlayMode,
                onPlayModeClick = onPlayModeClick,
                
                // [æ–°å¢] ä¾§è¾¹æ æŠ½å±‰æ•°æ®ä¸äº¤äº’
                relatedVideos = relatedVideos,
                ugcSeason = ugcSeason,
                isFollowed = isFollowed,
                isLiked = isLiked,
                isCoined = isCoined,
                isFavorited = isFavorited,
                onToggleFollow = onToggleFollow,
                onToggleLike = onToggleLike,
                onCoin = onCoin,
                onToggleFavorite = onToggleFavorite,
                onDrawerVideoClick = { vid ->
                    onRelatedVideoClick(vid, null) 
                },
                pages = uiState.info.pages,
                currentPageIndex = currentPageIndex,
                onPageSelect = onPageSelect,
                drawerHazeState = overlayDrawerHazeState
            )
    }



    // [æ–°å¢] è¿”å›æ—¶çš„è§¦æ„Ÿåé¦ˆ
    val haptic = androidx.compose.ui.platform.LocalHapticFeedback.current
    val hapticScope = rememberCoroutineScope()

    // æ‹¦æˆªç³»ç»Ÿè¿”å›äº‹ä»¶ (ä»…åœ¨å…¨å±æ—¶æ‹¦æˆªä»¥å¤„ç†é€€å‡ºå…¨å±ï¼Œå¦åˆ™äº¤ç»™ç³»ç»Ÿå¤„ç†é¢„æµ‹æ€§è¿”å›)
    BackHandler(enabled = !isScreenLocked && isFullscreen) {
        onToggleFullscreen()
    }
    }
}
