// æ–‡ä»¶è·¯å¾„: feature/home/HomeScreen.kt
package com.android.purebilibili.feature.home

import android.annotation.SuppressLint
import android.content.Context
import androidx.compose.animation.*
import androidx.compose.animation.core.tween
import androidx.compose.animation.core.LinearOutSlowInEasing
import androidx.compose.animation.core.FastOutLinearInEasing
import androidx.compose.foundation.ExperimentalFoundationApi //  Added
import androidx.compose.foundation.LocalOverscrollFactory // [Fix] Import for disabling overscroll (New API)
import androidx.compose.foundation.gestures.detectHorizontalDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.*
import androidx.compose.foundation.lazy.staggeredgrid.*  // ğŸŒŠ ç€‘å¸ƒæµå¸ƒå±€
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.material3.pulltorefresh.PullToRefreshBox
import androidx.compose.material3.pulltorefresh.rememberPullToRefreshState
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.zIndex
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.graphics.luminance  //  çŠ¶æ€æ äº®åº¦è®¡ç®—
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.android.purebilibili.core.theme.BiliPink
import com.android.purebilibili.feature.settings.GITHUB_URL
import com.android.purebilibili.core.store.SettingsManager //  å¼•å…¥ SettingsManager
//  ä» components åŒ…å¯¼å…¥æ‹†åˆ†åçš„ç»„ä»¶
import com.android.purebilibili.feature.home.components.BottomNavItem
import com.android.purebilibili.feature.home.components.FluidHomeTopBar
import com.android.purebilibili.feature.home.components.FrostedSideBar
import com.android.purebilibili.feature.home.components.CategoryTabRow
import com.android.purebilibili.feature.home.components.iOSHomeHeader  //  iOS å¤§æ ‡é¢˜å¤´éƒ¨
import com.android.purebilibili.feature.home.components.iOSRefreshIndicator  //  iOS ä¸‹æ‹‰åˆ·æ–°æŒ‡ç¤ºå™¨
//  ä» cards å­åŒ…å¯¼å…¥å¡ç‰‡ç»„ä»¶
import com.android.purebilibili.feature.home.components.cards.ElegantVideoCard
import com.android.purebilibili.feature.home.components.cards.LiveRoomCard
import com.android.purebilibili.feature.home.components.cards.StoryVideoCard   //  æ•…äº‹å¡ç‰‡
import com.android.purebilibili.core.ui.LoadingAnimation
import com.android.purebilibili.core.ui.VideoCardSkeleton
import com.android.purebilibili.core.ui.ErrorState as ModernErrorState
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.hazeSource
import com.android.purebilibili.core.ui.shimmer
import com.android.purebilibili.core.ui.LocalSharedTransitionScope  //  å…±äº«è¿‡æ¸¡
import com.android.purebilibili.core.ui.animation.DissolvableVideoCard  //  ç²’å­æ¶ˆæ•£åŠ¨ç”»
import com.android.purebilibili.core.ui.animation.jiggleOnDissolve      // ğŸ“³ iOS é£æ ¼æŠ–åŠ¨æ•ˆæœ
import com.android.purebilibili.core.util.responsiveContentWidth
import io.github.alexzhirkevich.cupertino.CupertinoActivityIndicator
import coil.imageLoader
import kotlinx.coroutines.launch
import kotlinx.coroutines.flow.distinctUntilChanged  //  æ€§èƒ½ä¼˜åŒ–ï¼šé˜²æ­¢é‡å¤è§¦å‘
import androidx.compose.animation.ExperimentalSharedTransitionApi  //  å…±äº«è¿‡æ¸¡å®éªŒAPI
import com.android.purebilibili.core.ui.LocalSetBottomBarVisible
import com.android.purebilibili.core.ui.LocalBottomBarVisible

import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.receiveAsFlow

// [æ–°å¢] å…¨å±€å›é¡¶äº‹ä»¶é€šé“
val LocalHomeScrollChannel = compositionLocalOf<Channel<Unit>?> { null }

@SuppressLint("UnusedMaterial3ScaffoldPaddingParameter")
@OptIn(ExperimentalMaterial3Api::class, ExperimentalSharedTransitionApi::class, ExperimentalFoundationApi::class)
@Composable
fun HomeScreen(
    viewModel: HomeViewModel = viewModel(),
    onVideoClick: (String, Long, String) -> Unit,
    onAvatarClick: () -> Unit,
    onProfileClick: () -> Unit,
    onSettingsClick: () -> Unit,
    onSearchClick: () -> Unit,
    //  æ–°å¢ï¼šåŠ¨æ€é¡µé¢å›è°ƒ
    onDynamicClick: () -> Unit = {},
    //  æ–°å¢ï¼šå†å²è®°å½•å›è°ƒ
    onHistoryClick: () -> Unit = {},
    //  æ–°å¢ï¼šåˆ†åŒºå›è°ƒ
    onPartitionClick: () -> Unit = {},
    //  æ–°å¢ï¼šç›´æ’­ç‚¹å‡»å›è°ƒ
    onLiveClick: (Long, String, String) -> Unit = { _, _, _ -> },  // roomId, title, uname
    //  [ä¿®å¤] ç•ªå‰§/å½±è§†å›è°ƒï¼Œæ¥å—ç±»å‹å‚æ•° (1=ç•ªå‰§ 2=ç”µå½± ç­‰)
    onBangumiClick: (Int) -> Unit = {},
    //  æ–°å¢ï¼šåˆ†ç±»ç‚¹å‡»å›è°ƒï¼ˆç”¨äºæ¸¸æˆã€çŸ¥è¯†ã€ç§‘æŠ€ç­‰åˆ†ç±»ï¼Œä¼ å…¥ tid å’Œ nameï¼‰
    onCategoryClick: (Int, String) -> Unit = { _, _ -> },
    //  [æ–°å¢] åº•æ æ‰©å±•é¡¹ç›®å¯¼èˆªå›è°ƒ
    onFavoriteClick: () -> Unit = {},  // æ”¶è—é¡µé¢
    onLiveListClick: () -> Unit = {},  // ç›´æ’­åˆ—è¡¨é¡µé¢
    onWatchLaterClick: () -> Unit = {},  // ç¨åå†çœ‹é¡µé¢
    onStoryClick: () -> Unit = {},  //  [æ–°å¢] ç«–å±çŸ­è§†é¢‘
    globalHazeState: dev.chrisbanes.haze.HazeState? = null  //  [æ–°å¢] å…¨å±€åº•æ æ¨¡ç³ŠçŠ¶æ€
) {
    val state by viewModel.uiState.collectAsState()
    val isRefreshing by viewModel.isRefreshing.collectAsState()
// val pullRefreshState = rememberPullToRefreshState() // [Removed] Moved inside HorizontalPager
    val context = LocalContext.current
    //  [Refactor] Use a map of grid states for each category to support HorizontalPager
    val gridStates = remember { mutableMapOf<HomeCategory, LazyGridState>() }
    HomeCategory.entries.forEach { category ->
        gridStates[category] = rememberLazyGridState()
    }
    val staggeredGridState = rememberLazyStaggeredGridState()  // ğŸŒŠ ç€‘å¸ƒæµçŠ¶æ€
    val hazeState = remember { HazeState() }
    val coroutineScope = rememberCoroutineScope()  //  ç”¨äºåŒå‡»å›é¡¶åŠ¨ç”»
    
    // [æ–°å¢] ç›‘å¬å…¨å±€å›é¡¶äº‹ä»¶
    val scrollChannel = LocalHomeScrollChannel.current
    LaunchedEffect(scrollChannel) {
        scrollChannel?.receiveAsFlow()?.collect {
            launch {
                val gridState = gridStates[state.currentCategory]
                val isAtTop = gridState == null || (gridState.firstVisibleItemIndex == 0 && gridState.firstVisibleItemScrollOffset < 50)

                if (isAtTop) {
                    viewModel.refresh()
                } else {
                    gridState?.animateScrollToItem(0)
                }
            }
        }
    }

    // [Refactor] Hoist PagerState to be available for both Content and Header
    // ç¡®ä¿ pagerState åœ¨æ‰€æœ‰ä½œç”¨åŸŸå‡å¯è§ï¼Œä»¥ä¾¿ä¼ ç»™ iOSHomeHeader
    val initialPage = HomeCategory.entries.indexOf(state.currentCategory).coerceAtLeast(0)
    val pagerState = androidx.compose.foundation.pager.rememberPagerState(initialPage = initialPage) { HomeCategory.entries.size }
    
    // [ä¿®å¤] åˆ·æ–°æ—¶è‡ªåŠ¨æ»šå›é¡¶éƒ¨ï¼Œé˜²æ­¢ä¸‹æ‹‰ç”¨åŠ›è¿‡çŒ›å¯¼è‡´å†…å®¹åç§»
    LaunchedEffect(isRefreshing) {
        if (isRefreshing) {
            gridStates[state.currentCategory]?.animateScrollToItem(0)
        }
    }
    
    //  [æ–°å¢] JSON æ’ä»¶è¿‡æ»¤æç¤º
    val snackbarHostState = remember { SnackbarHostState() }
    val lastFilteredCount by com.android.purebilibili.core.plugin.json.JsonPluginManager.lastFilteredCount.collectAsState()
    
    //  å½“æœ‰è§†é¢‘è¢«è¿‡æ»¤æ—¶æ˜¾ç¤ºæç¤º
    LaunchedEffect(lastFilteredCount) {
        if (lastFilteredCount > 0) {
            snackbarHostState.showSnackbar(
                message = " å·²è¿‡æ»¤ $lastFilteredCount ä¸ªè§†é¢‘",
                duration = SnackbarDuration.Short
            )
        }
    }
    
    //  [åŸ‹ç‚¹] é¡µé¢æµè§ˆè¿½è¸ª
    LaunchedEffect(Unit) {
        com.android.purebilibili.core.util.AnalyticsHelper.logScreenView("HomeScreen")
    }
    
    //  [åŸ‹ç‚¹] åˆ†ç±»åˆ‡æ¢è¿½è¸ª
    LaunchedEffect(state.currentCategory) {
        com.android.purebilibili.core.util.AnalyticsHelper.logCategoryView(
            categoryName = state.currentCategory.label,
            categoryId = state.currentCategory.tid
        )
    }
    
    //  [å½©è›‹] å½©è›‹å¼€å…³è®¾ç½®
    val easterEggEnabled by SettingsManager.getEasterEggEnabled(context).collectAsState(initial = true)
    var showEasterEggDialog by remember { mutableStateOf(false) }
    
    //  [å½©è›‹] ä¸‹æ‹‰åˆ·æ–°æˆåŠŸåæ˜¾ç¤ºè¶£å‘³æç¤ºï¼ˆä»…åœ¨å¼€å…³å¼€å¯æ—¶ï¼‰
    LaunchedEffect(state.refreshKey, easterEggEnabled) {
        val message = state.refreshMessage
        if (message != null && state.refreshKey > 0 && easterEggEnabled) {
            val result = snackbarHostState.showSnackbar(
                message = message,
                actionLabel = "å…³é—­å½©è›‹",
                duration = SnackbarDuration.Short
            )
            if (result == SnackbarResult.ActionPerformed) {
                showEasterEggDialog = true
            }
        }
    }
    
    //  [å½©è›‹] å…³é—­ç¡®è®¤å¯¹è¯æ¡†
    if (showEasterEggDialog) {
        androidx.compose.material3.AlertDialog(
            onDismissRequest = { showEasterEggDialog = false },
            title = { 
                Text(
                    "å…³é—­è¶£å‘³æç¤ºï¼Ÿ", 
                    color = MaterialTheme.colorScheme.onSurface
                ) 
            },
            text = { 
                Text(
                    "å…³é—­åä¸‹æ‹‰åˆ·æ–°å°†ä¸å†æ˜¾ç¤ºè¶£å‘³æ¶ˆæ¯ã€‚\n\nä½ å¯ä»¥åœ¨ã€Œè®¾ç½®ã€ä¸­éšæ—¶é‡æ–°å¼€å¯ã€‚",
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                ) 
            },
            confirmButton = {
                androidx.compose.material3.TextButton(
                    onClick = {
                        coroutineScope.launch {
                            SettingsManager.setEasterEggEnabled(context, false)
                        }
                        showEasterEggDialog = false
                    }
                ) { Text("å…³é—­å½©è›‹", color = MaterialTheme.colorScheme.error) }
            },
            dismissButton = {
                androidx.compose.material3.TextButton(
                    onClick = { showEasterEggDialog = false }
                ) { Text("ä¿ç•™å½©è›‹", color = MaterialTheme.colorScheme.primary) }
            },
            containerColor = MaterialTheme.colorScheme.surface
        )
    }
    
    //  [ä¿®å¤] ç¡®ä¿é¦–é¡µæ˜¾ç¤ºæ—¶ WindowInsets é…ç½®æ­£ç¡®ï¼Œé˜²æ­¢ä»è§†é¢‘é¡µè¿”å›æ—¶å¸ƒå±€è·³åŠ¨
    val view = androidx.compose.ui.platform.LocalView.current
    SideEffect {
        val window = (view.context as? android.app.Activity)?.window ?: return@SideEffect
        // ä¿æŒè¾¹åˆ°è¾¹æ˜¾ç¤ºï¼ˆä¸ VideoDetailScreen ä¸€è‡´ï¼‰
        androidx.core.view.WindowCompat.setDecorFitsSystemWindows(window, false)
    }

    //  [æ€§èƒ½ä¼˜åŒ–] åˆå¹¶é¦–é¡µè®¾ç½®ä¸ºå•ä¸€ Flowï¼Œå‡å°‘ 6 ä¸ª collectAsState â†’ 1 ä¸ª
    val homeSettings by SettingsManager.getHomeSettings(context).collectAsState(
        initial = com.android.purebilibili.core.store.HomeSettings()
    )
    
    // è§£æ„è®¾ç½®å€¼ï¼ˆé¿å…æ¯æ¬¡è®¿é—®éƒ½è§¦å‘é‡ç»„ï¼‰
    val displayMode = homeSettings.displayMode
    val isBottomBarFloating = homeSettings.isBottomBarFloating
    val bottomBarLabelMode = homeSettings.bottomBarLabelMode
    val isHeaderBlurEnabled = homeSettings.isHeaderBlurEnabled
    val isBottomBarBlurEnabled = homeSettings.isBottomBarBlurEnabled
    val crashTrackingConsentShown = homeSettings.crashTrackingConsentShown
    val cardAnimationEnabled = homeSettings.cardAnimationEnabled      //  å¡ç‰‡è¿›åœºåŠ¨ç”»å¼€å…³
    val cardTransitionEnabled = homeSettings.cardTransitionEnabled    //  å¡ç‰‡è¿‡æ¸¡åŠ¨ç”»å¼€å…³
    
    //  [æ–°å¢] åº•æ å¯è§é¡¹ç›®é…ç½®
    val orderedVisibleTabIds by SettingsManager.getOrderedVisibleTabs(context).collectAsState(
        initial = listOf("HOME", "DYNAMIC", "HISTORY", "PROFILE")
    )
    // å°†å­—ç¬¦ä¸² ID è½¬æ¢ä¸º BottomNavItem æšä¸¾
    val visibleBottomBarItems = remember(orderedVisibleTabIds) {
        orderedVisibleTabIds.mapNotNull { id ->
            try { BottomNavItem.valueOf(id) } catch (e: Exception) { null }
        }
    }
    
    //  [æ–°å¢] åº•æ é¡¹ç›®é¢œè‰²é…ç½®
    val bottomBarItemColors by SettingsManager.getBottomBarItemColors(context).collectAsState(initial = emptyMap<String, Int>())

    
    //  ğŸ“ [å¹³æ¿é€‚é…] æ ¹æ®å±å¹•å°ºå¯¸å’Œå±•ç¤ºæ¨¡å¼åŠ¨æ€è®¾ç½®ç½‘æ ¼åˆ—æ•°
    // æ•…äº‹å¡ç‰‡éœ€è¦å•åˆ—å…¨å®½ï¼Œç½‘æ ¼å’Œç»ç’ƒä½¿ç”¨åŒåˆ—ï¼Œå¹³æ¿ç«¯ä½¿ç”¨å¤šåˆ—
    val windowSizeClass = com.android.purebilibili.core.util.LocalWindowSizeClass.current
    val contentWidth = if (windowSizeClass.isExpandedScreen) {
        minOf(windowSizeClass.widthDp, 1000.dp)
    } else {
        windowSizeClass.widthDp
    }
    val adaptiveColumns = remember(contentWidth, displayMode) {
        val minColumnWidth = if (displayMode == 1) 240.dp else 180.dp
        val maxColumns = if (displayMode == 1) 2 else 6
        val columns = (contentWidth / minColumnWidth).toInt()
        columns.coerceIn(1, maxColumns)
    }
    val gridColumns = if (windowSizeClass.isExpandedScreen) {
        adaptiveColumns
    } else {
        com.android.purebilibili.core.util.rememberResponsiveValue(
            compact = if (displayMode == 1) 1 else 2,  // æ‰‹æœºï¼šæ•…äº‹1åˆ—ï¼Œå…¶ä»–2åˆ—
            medium = if (displayMode == 1) 2 else 3    // ä¸­ç­‰å®½åº¦ï¼šæ•…äº‹2åˆ—ï¼Œå…¶å®ƒ3åˆ—
        )
    }
    
    
    //  ï¿½ [å¹³æ¿å¯¼èˆªåˆ‡æ¢] ç”¨æˆ·åå¥½è®¾ç½®
    val tabletUseSidebar by SettingsManager.getTabletUseSidebar(context).collectAsState(initial = false)
    
    //  ï¿½ğŸ“ [å¤§å±é€‚é…] å¹³æ¿å¯¼èˆªæ¨¡å¼ï¼šæ ¹æ®ç”¨æˆ·åå¥½å†³å®š
    // ä»…åœ¨å¹³æ¿ä¸”ç”¨æˆ·é€‰æ‹©äº†ä¾§è¾¹æ æ—¶ä½¿ç”¨ä¾§è¾¹å¯¼èˆª
    val useSideNavigation = windowSizeClass.isExpandedScreen && tabletUseSidebar
    
    //  ğŸ“± [åˆ‡æ¢å¯¼èˆªæ¨¡å¼] å¤„ç†å‡½æ•°
    val onToggleNavigationMode: () -> Unit = {
        coroutineScope.launch {
            SettingsManager.setTabletUseSidebar(context, !tabletUseSidebar)
        }
    }

    //  [ä¿®å¤] æ¢å¤çŠ¶æ€æ æ ·å¼ï¼šç¡®ä¿ä»è§†é¢‘è¯¦æƒ…é¡µè¿”å›åçŠ¶æ€æ æ­£ç¡®
    // å½“ä½¿ç”¨æ»‘åŠ¨åŠ¨ç”»æ—¶ï¼ŒTheme.kt çš„ SideEffect å¯èƒ½ä¸ä¼šé‡æ–°æ‰§è¡Œ
    val backgroundColor = MaterialTheme.colorScheme.background
    val isLightBackground = remember(backgroundColor) { backgroundColor.luminance() > 0.5f }
    
    if (!view.isInEditMode) {
        SideEffect {
            val window = (context as? android.app.Activity)?.window ?: return@SideEffect
            val insetsController = androidx.core.view.WindowCompat.getInsetsController(window, view)
            //  æ ¹æ®èƒŒæ™¯äº®åº¦è®¾ç½®çŠ¶æ€æ å›¾æ ‡é¢œè‰²
            insetsController.isAppearanceLightStatusBars = isLightBackground
            //  [ä¿®å¤] å¯¼èˆªæ ä¹Ÿéœ€è¦æ ¹æ®èƒŒæ™¯äº®åº¦è®¾ç½®å›¾æ ‡é¢œè‰²
            insetsController.isAppearanceLightNavigationBars = isLightBackground
            //  ç¡®ä¿çŠ¶æ€æ å¯è§ä¸”é€æ˜
            insetsController.show(androidx.core.view.WindowInsetsCompat.Type.statusBars())
            window.statusBarColor = android.graphics.Color.TRANSPARENT
            //  [ä¿®å¤] å¯¼èˆªæ ä¹Ÿè®¾ä¸ºé€æ˜ï¼Œç¡®ä¿åº•æ éšè—æ—¶æ‰‹åŠ¿åŒºåŸŸæ²‰æµ¸
            window.navigationBarColor = android.graphics.Color.TRANSPARENT
        }
    }

    val density = LocalDensity.current
    val navBarHeight = WindowInsets.navigationBars.getBottom(density).let { with(density) { it.toDp() } }
    
    val bottomBarHeight = if (isBottomBarFloating) {
        84.dp + navBarHeight  // 72dp(æ é«˜åº¦) + 12dp(åº•éƒ¨è¾¹è·)
    } else {
        64.dp + navBarHeight  // 64dp(Dockedæ¨¡å¼)
    }

    //  [ä¿®å¤] åŠ¨æ€è®¡ç®—å†…å®¹é¡¶éƒ¨è¾¹è·ï¼Œé˜²æ­¢è¢«å¤´éƒ¨é®æŒ¡
    val statusBarHeight = WindowInsets.statusBars.asPaddingValues().calculateTopPadding()
    val listTopPadding = statusBarHeight + 120.dp  // [è°ƒæ•´] ä¼˜åŒ–é¡¶éƒ¨é—´è· (110 -> 120) å¢åŠ å‘¼å¸æ„Ÿ

    val prefs = remember { context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE) }
    
    //  å½“å‰é€‰ä¸­çš„å¯¼èˆªé¡¹
    var currentNavItem by remember { mutableStateOf(BottomNavItem.HOME) }

    // ç»Ÿä¸€å¯¼èˆªç‚¹å‡»é€»è¾‘ï¼ˆåº•æ /ä¾§æ å¤ç”¨ï¼‰
    val handleNavItemClick: (BottomNavItem) -> Unit = { item ->
        currentNavItem = item
        when (item) {
            BottomNavItem.HOME -> {
                coroutineScope.launch { 
                    val gridState = gridStates[state.currentCategory]
                    val isAtTop = gridState == null || (gridState.firstVisibleItemIndex == 0 && gridState.firstVisibleItemScrollOffset < 50)
                    
                    if (isAtTop) {
                        viewModel.refresh()
                    } else {
                        gridState?.animateScrollToItem(0) 
                    } 
                }
            }
            BottomNavItem.DYNAMIC -> onDynamicClick()
            BottomNavItem.HISTORY -> onHistoryClick()
            BottomNavItem.PROFILE -> onProfileClick()
            BottomNavItem.FAVORITE -> onFavoriteClick()
            BottomNavItem.LIVE -> onLiveListClick()
            BottomNavItem.WATCHLATER -> onWatchLaterClick()
            BottomNavItem.STORY -> onStoryClick()
            BottomNavItem.SETTINGS -> onSettingsClick()
        }
    }
    
    //  [æ–°å¢] åº•æ æ˜¾ç¤ºæ¨¡å¼è®¾ç½®
    val bottomBarVisibilityMode by SettingsManager.getBottomBarVisibilityMode(context).collectAsState(
        initial = SettingsManager.BottomBarVisibilityMode.ALWAYS_VISIBLE
    )
    
    //  [Refactor] ä½¿ç”¨å…¨å±€ CompositionLocal æ§åˆ¶åº•æ å¯è§æ€§
    val setBottomBarVisible = LocalSetBottomBarVisible.current
    val isGlobalBottomBarVisible = LocalBottomBarVisible.current
    // å…¼å®¹ä»£ç ï¼šä¸ºäº†æœ€å°åŒ–æ”¹åŠ¨ï¼Œå°† bottomBarVisible æŒ‡å‘å…¨å±€çŠ¶æ€
    // æ³¨æ„ï¼šè¿™é‡Œçš„ bottomBarVisible ç°åœ¨æ˜¯åªè¯»çš„ï¼Œä¿®æ”¹å¿…é¡»é€šè¿‡ setBottomBarVisible
    val bottomBarVisible = isGlobalBottomBarVisible
    
    //  [ä¿®å¤] è·Ÿè¸ªæ˜¯å¦æ­£åœ¨å¯¼èˆªåˆ°/ä»è§†é¢‘é¡µ - å¿…é¡»åœ¨ LaunchedEffect ä¹‹å‰å£°æ˜
    var isVideoNavigating by remember { mutableStateOf(false) }
    
    //  [æ–°å¢] æ»šåŠ¨æ–¹å‘æ£€æµ‹çŠ¶æ€ï¼ˆç”¨äºä¸Šæ»‘éšè—æ¨¡å¼ï¼‰
    var lastScrollOffset by remember { mutableIntStateOf(0) }
    var lastFirstVisibleItem by remember { mutableIntStateOf(0) }
    
    //  [æ–°å¢] æ»šåŠ¨æ–¹å‘æ£€æµ‹é€»è¾‘
    LaunchedEffect(state.currentCategory, bottomBarVisibilityMode, useSideNavigation) {
        if (useSideNavigation) {
            setBottomBarVisible(false)
            return@LaunchedEffect
        }
        if (bottomBarVisibilityMode != SettingsManager.BottomBarVisibilityMode.SCROLL_HIDE) {
            // éæ»šåŠ¨éšè—æ¨¡å¼æ—¶ï¼Œæ ¹æ®è®¾ç½®å†³å®šåº•æ å¯è§æ€§
            setBottomBarVisible(bottomBarVisibilityMode == SettingsManager.BottomBarVisibilityMode.ALWAYS_VISIBLE)
            return@LaunchedEffect
        }
        
        // ä¸Šæ»‘éšè—æ¨¡å¼ï¼šç›‘å¬æ»šåŠ¨æ–¹å‘
        val currentGridState = gridStates[state.currentCategory] ?: return@LaunchedEffect
        snapshotFlow {
            Pair(currentGridState.firstVisibleItemIndex, currentGridState.firstVisibleItemScrollOffset)
        }
        .distinctUntilChanged()
        .collect { (firstVisibleItem, scrollOffset) ->
            // è§†é¢‘å¯¼èˆªæœŸé—´ä¸å¤„ç†æ»šåŠ¨éšè—
            if (isVideoNavigating) return@collect
            
            // æ»šåŠ¨åˆ°é¡¶éƒ¨æ—¶å§‹ç»ˆæ˜¾ç¤º
            if (firstVisibleItem == 0 && scrollOffset < 100) {
                setBottomBarVisible(true)
            } else {
                // è®¡ç®—æ»šåŠ¨æ–¹å‘
                val isScrollingDown = when {
                    firstVisibleItem > lastFirstVisibleItem -> true
                    firstVisibleItem < lastFirstVisibleItem -> false
                    else -> scrollOffset > lastScrollOffset + 200 // [UXä¼˜åŒ–] å¢å¤§è¿Ÿæ»é˜ˆå€¼ (30 -> 200) é˜²æ­¢å¾®å°æŠ–åŠ¨
                }
                val isScrollingUp = when {
                    firstVisibleItem < lastFirstVisibleItem -> true
                    firstVisibleItem > lastFirstVisibleItem -> false
                    else -> scrollOffset < lastScrollOffset - 200 // [UXä¼˜åŒ–] å¢å¤§è¿Ÿæ»é˜ˆå€¼
                }
                
                if (isScrollingDown) setBottomBarVisible(false)
                else if (isScrollingUp) setBottomBarVisible(true)
            }
            
            lastFirstVisibleItem = firstVisibleItem
            lastScrollOffset = scrollOffset
        }
    }
    
    //  [ä¿®å¤] ç”¨äºå–æ¶ˆå»¶è¿Ÿåç¨‹çš„ Job å¼•ç”¨
    var bottomBarRestoreJob by remember { mutableStateOf<kotlinx.coroutines.Job?>(null) }
    
    //  åŒ…è£… onVideoClickï¼šç‚¹å‡»è§†é¢‘æ—¶å…ˆéšè—åº•æ å†å¯¼èˆª
    val wrappedOnVideoClick: (String, Long, String) -> Unit = remember(onVideoClick) {
        { bvid, cid, cover ->
            //  å–æ¶ˆä¹‹å‰çš„æ¢å¤åç¨‹ï¼Œé˜²æ­¢ç«æ€æ¡ä»¶
            bottomBarRestoreJob?.cancel()
            bottomBarRestoreJob = null
            
            setBottomBarVisible(false)  //  è§¦å‘åº•æ ä¸‹æ»‘åŠ¨ç”»
            isVideoNavigating = true  //  æ ‡è®°æ­£åœ¨å¯¼èˆªåˆ°è§†é¢‘
            onVideoClick(bvid, cid, cover)
        }
    }
    
    //  [ä¿®å¤] ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸäº‹ä»¶æ§åˆ¶åº•æ å¯è§æ€§
    // ON_START: æ¢å¤åº•æ ï¼ˆä»…åœ¨ä»è§†é¢‘é¡µè¿”å›æ—¶ï¼‰
    // ON_STOP: éšè—åº•æ ï¼ˆå¯¼èˆªåˆ°å…¶ä»–é¡µé¢æ—¶ï¼Œé¿å…å½±å“å¯¼èˆªæ åŒºåŸŸï¼‰
    val lifecycleOwner = androidx.compose.ui.platform.LocalLifecycleOwner.current
    DisposableEffect(lifecycleOwner, useSideNavigation) {
        if (useSideNavigation) {
            return@DisposableEffect onDispose { }
        }
        val observer = androidx.lifecycle.LifecycleEventObserver { _, event ->
            when (event) {
                androidx.lifecycle.Lifecycle.Event.ON_START -> {
                    //  å…³é”®ä¿®å¤ï¼šåªåœ¨åº•æ å½“å‰éšè—æ—¶æ‰æ¢å¤å¯è§
                    if (!bottomBarVisible && isVideoNavigating) {
                        //  [åŒæ­¥åŠ¨ç”»] å»¶è¿Ÿåå†æ˜¾ç¤ºåº•æ ï¼Œè®©è¿›å…¥åŠ¨ç”»ä¸å¡ç‰‡è¿”å›åŠ¨ç”»åŒæ­¥
                        bottomBarRestoreJob = kotlinx.coroutines.MainScope().launch {
                            kotlinx.coroutines.delay(100)  // ç­‰å¾…è¿”å›åŠ¨ç”»å¼€å§‹
                            setBottomBarVisible(true)
                            // å»¶è¿Ÿé‡ç½®å¯¼èˆªçŠ¶æ€ï¼Œç¡®ä¿è¿›å…¥åŠ¨ç”»å®Œæˆ
                            kotlinx.coroutines.delay(400)
                            isVideoNavigating = false
                        }
                    } else if (!bottomBarVisible && !isVideoNavigating) {
                        //  [æ–°å¢] ä»è®¾ç½®ç­‰éè§†é¢‘é¡µé¢è¿”å›æ—¶ï¼Œç«‹å³æ˜¾ç¤ºåº•æ ï¼ˆæ— å»¶è¿Ÿï¼‰
                        setBottomBarVisible(true)
                    }
                }
                androidx.lifecycle.Lifecycle.Event.ON_STOP -> {
                    //  [ä¿®å¤] ç§»é™¤æ­¤å¤„éšè—åº•æ çš„é€»è¾‘
                    //  é˜²æ­¢åˆ‡æ¢åˆ°å…¶ä»–Tabï¼ˆå¦‚åŠ¨æ€/å†å²ï¼‰æ—¶åº•æ æ¶ˆå¤±
                    bottomBarRestoreJob?.cancel()
                    bottomBarRestoreJob = null
                    // setBottomBarVisible(false) // REMOVED
                }
                else -> { /* å…¶ä»–äº‹ä»¶ä¸å¤„ç† */ }
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            bottomBarRestoreJob?.cancel()
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
    
    //  [ä¿®å¤] ä½¿ç”¨ ViewModel ä¸­çš„æ ‡ç­¾é¡µæ˜¾ç¤ºç´¢å¼•ï¼ˆè·¨å¯¼èˆªä¿æŒï¼‰
    // å½“ç”¨æˆ·æ»‘åŠ¨åˆ°ç‰¹æ®Šåˆ†ç±»æ—¶ï¼Œæ ‡ç­¾é¡µä½ç½®æ›´æ–°ï¼Œä½†å†…å®¹åˆ†ç±»ä¿æŒä¸å˜
    val displayedTabIndex = state.displayedTabIndex
    
    //  [ä¿®å¤] ä½¿ç”¨ rememberSaveable è®°ä½æœ¬æ¬¡ä¼šè¯ä¸­æ˜¯å¦å·²å¤„ç†è¿‡å¼¹çª—ï¼ˆé˜²æ­¢å¯¼èˆªåé‡æ–°æ˜¾ç¤ºï¼‰
    var consentDialogHandled by rememberSaveable { mutableStateOf(false) }
    var showConsentDialog by remember { mutableStateOf(false) }
    
    //  æ£€æŸ¥æ¬¢è¿å¼¹çª—æ˜¯å¦å·²æ˜¾ç¤ºè¿‡ï¼ˆç¡®ä¿å¼¹çª—é¡ºåºæ˜¾ç¤ºï¼Œä¸ä¼šåŒæ—¶å‡ºç°ï¼‰
    val welcomePrefs = remember { context.getSharedPreferences("app_welcome", Context.MODE_PRIVATE) }
    val welcomeAlreadyShown = welcomePrefs.getBoolean("first_launch_shown", false)
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºå¼¹çª—ï¼ˆæ¬¢è¿å¼¹çª—å·²æ˜¾ç¤ºè¿‡ ä¸” åŒæ„å¼¹çª—å°šæœªæ˜¾ç¤ºè¿‡ ä¸” æœ¬æ¬¡ä¼šè¯æœªå¤„ç†è¿‡ï¼‰
    LaunchedEffect(crashTrackingConsentShown) {
        if (welcomeAlreadyShown && !crashTrackingConsentShown && !consentDialogHandled) {
            showConsentDialog = true
        }
    }
    
    // æ˜¾ç¤ºå¼¹çª—
    if (showConsentDialog) {
        com.android.purebilibili.feature.home.components.CrashTrackingConsentDialog(
            onDismiss = { 
                showConsentDialog = false
                consentDialogHandled = true  // æ ‡è®°ä¸ºå·²å¤„ç†
            }
        )
    }
    
    //  è®¡ç®—æ»šåŠ¨åç§»é‡ç”¨äºå¤´éƒ¨åŠ¨ç”» -  ä¼˜åŒ–ï¼šé‡åŒ–å‡å°‘é‡ç»„
    //  è®¡ç®—æ»šåŠ¨åç§»é‡ç”¨äºå¤´éƒ¨åŠ¨ç”» -  ä¼˜åŒ–ï¼šé‡åŒ–å‡å°‘é‡ç»„
    val scrollOffset by remember {
        derivedStateOf {
            val currentGridState = gridStates[state.currentCategory]
            if (currentGridState == null) return@derivedStateOf 0f
            
            val firstVisibleItem = currentGridState.firstVisibleItemIndex
            if (firstVisibleItem == 0) {
                //  ç›´æ¥ä½¿ç”¨åŸå§‹åç§»é‡ï¼Œé¿å…é‡åŒ–å¯¼è‡´çš„è·³å˜
                currentGridState.firstVisibleItemScrollOffset.toFloat()
            } else 1000f
        }
    }
    
    //  æ»šåŠ¨æ–¹å‘ï¼ˆç®€åŒ–ç‰ˆ - ä¸å†éœ€è¦å¤æ‚æ£€æµ‹ï¼Œå› ä¸ºæ ‡ç­¾é¡µåªåœ¨é¡¶éƒ¨æ˜¾ç¤ºï¼‰
    val isScrollingUp = true  // ä¿ç•™å‚æ•°å…¼å®¹æ€§

    val shouldLoadMore by remember {
        derivedStateOf {
            val currentGridState = gridStates[state.currentCategory]
            if (currentGridState == null) return@derivedStateOf false

            val layoutInfo = currentGridState.layoutInfo
            val totalItems = layoutInfo.totalItemsCount
            val lastVisibleItemIndex = layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0
            totalItems > 0 && lastVisibleItemIndex >= totalItems - 4 && !state.isLoading && !isRefreshing
        }
    }
    LaunchedEffect(shouldLoadMore) { if (shouldLoadMore) viewModel.loadMore() }
    
    //  [æ€§èƒ½ä¼˜åŒ–] å›¾ç‰‡é¢„åŠ è½½ - æå‰åŠ è½½å³å°†æ˜¾ç¤ºçš„è§†é¢‘å°é¢
    // ğŸ“‰ [çœæµé‡] çœæµé‡æ¨¡å¼ä¸‹ç¦ç”¨é¢„åŠ è½½
    val isDataSaverActive = remember {
        com.android.purebilibili.core.store.SettingsManager.isDataSaverActive(context)
    }
    
    LaunchedEffect(state.currentCategory, isDataSaverActive) {
        // ğŸ“‰ çœæµé‡æ¨¡å¼ä¸‹è·³è¿‡é¢„åŠ è½½
        if (isDataSaverActive) return@LaunchedEffect
        
        val currentGridState = gridStates[state.currentCategory] ?: return@LaunchedEffect
        
        snapshotFlow { currentGridState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0 }
            .distinctUntilChanged()  //  åªåœ¨ç´¢å¼•å˜åŒ–æ—¶è§¦å‘
            .collect { lastVisibleIndex ->
                val videos = state.videos
                val preloadStart = (lastVisibleIndex + 1).coerceAtMost(videos.size)
                val preloadEnd = (lastVisibleIndex + 6).coerceAtMost(videos.size)  //  å‡å°‘é¢„åŠ è½½æ•°é‡
                
                if (preloadStart < preloadEnd) {
                    for (i in preloadStart until preloadEnd) {
                        val imageUrl = videos.getOrNull(i)?.pic ?: continue
                        val request = coil.request.ImageRequest.Builder(context)
                            .data(com.android.purebilibili.core.util.FormatUtils.fixImageUrl(imageUrl))
                            .size(360, 225)  //  é¢„åŠ è½½ä¹Ÿä½¿ç”¨é™åˆ¶å°ºå¯¸
                            .memoryCachePolicy(coil.request.CachePolicy.ENABLED)
                            .diskCachePolicy(coil.request.CachePolicy.ENABLED)
                            .build()
                        context.imageLoader.enqueue(request)
                    }
                }
            }
    }


    //  PullToRefreshBox è‡ªåŠ¨å¤„ç†ä¸‹æ‹‰åˆ·æ–°é€»è¾‘
    
    //  [å·²ç§»é™¤] ç‰¹æ®Šåˆ†ç±»ï¼ˆANIME, MOVIEç­‰ï¼‰ä¸å†åœ¨é¦–é¡µåˆ‡æ¢ï¼Œç›´æ¥å¯¼èˆªåˆ°ç‹¬ç«‹é¡µé¢
    
    //  [ä¿®å¤] å¦‚æœå½“å‰åœ¨ç›´æ’­-å…³æ³¨åˆ†ç±»ä¸”åˆ—è¡¨ä¸ºç©ºï¼Œè¿”å›æ—¶å…ˆåˆ‡æ¢åˆ°çƒ­é—¨ï¼Œå†åˆ‡æ¢åˆ°æ¨è
    val isEmptyLiveFollowed = state.currentCategory == HomeCategory.LIVE && 
                               state.liveSubCategory == LiveSubCategory.FOLLOWED &&
                               state.liveRooms.isEmpty() && 
                               !state.isLoading
    androidx.activity.compose.BackHandler(enabled = isEmptyLiveFollowed) {
        // åˆ‡æ¢åˆ°çƒ­é—¨ç›´æ’­
        viewModel.switchLiveSubCategory(LiveSubCategory.POPULAR)
    }

    //  [ä¿®å¤] å¦‚æœå½“å‰åœ¨ç›´æ’­åˆ†ç±»ï¼ˆéå…³æ³¨ç©ºåˆ—è¡¨æƒ…å†µï¼‰ï¼Œè¿”å›æ—¶åˆ‡æ¢åˆ°æ¨è
    val isLiveCategoryNotHome = state.currentCategory == HomeCategory.LIVE && !isEmptyLiveFollowed
    androidx.activity.compose.BackHandler(enabled = isLiveCategoryNotHome) {
        viewModel.switchCategory(HomeCategory.RECOMMEND)
    }
    
// [Removed] Animation logic moved inside HorizontalPager where the active state exists
    
    // æŒ‡ç¤ºå™¨ä½ç½®é€»è¾‘ä¹Ÿç§»å…¥ graphicsLayer
    
    val scaffoldContent: @Composable () -> Unit = {
    Scaffold(
        //  [æ–°å¢] JSON æ’ä»¶è¿‡æ»¤æç¤º
        snackbarHost = {
            SnackbarHost(
                hostState = snackbarHostState,
                modifier = Modifier.padding(
                    bottom = when {
                        useSideNavigation -> navBarHeight + 8.dp
                        isBottomBarFloating -> 100.dp
                        else -> 80.dp
                    }
                )
            )
        },
        //  [ä¿®å¤] ç¦ç”¨ Scaffold é»˜è®¤çš„ contentWindowInsetsï¼Œé˜²æ­¢åº•éƒ¨å‡ºç°ç™½è‰²å¡«å……
        contentWindowInsets = WindowInsets(0),
        containerColor = MaterialTheme.colorScheme.background
    ) { padding ->
        //  [é‡æ„] å®ç°çœŸæ­£çš„æ¯›ç»ç’ƒæ•ˆæœ
        // å¤–å±‚ Box åŒ…å«ï¼š1) hazeSource å†…å®¹å±‚  2) Header overlay å±‚
        // Header åœ¨ hazeSource å¤–éƒ¨ï¼Œå¯ä»¥æ­£ç¡®æ¨¡ç³Šå†…å±‚å†…å®¹
        Box(
            modifier = Modifier.fillMaxSize()
        ) {
            // ===== å†…å®¹å±‚ (hazeSource) =====
            // [ä¿®å¤] å¦‚æœæœ‰å…¨å±€ hazeStateï¼ŒåŒæ—¶åº”ç”¨ä¸¤ä¸ª hazeSource
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    // [Fix] Move local hazeSource deeper to avoid drawing hierarchy crash
                    // .hazeSource(state = hazeState) 
                    .then(if (globalHazeState != null) Modifier.hazeSource(state = globalHazeState) else Modifier)  // å…¨å±€ hazeSource - åº•æ ä½¿ç”¨
            ) {
            if (state.isLoading && state.videos.isEmpty() && state.liveRooms.isEmpty()) {
                //  é¦–æ¬¡åŠ è½½æ”¹ä¸ºéª¨æ¶å±
                LazyVerticalGrid(
                    columns = GridCells.Fixed(gridColumns),
                    contentPadding = PaddingValues(
                        top = 0.dp,  //  [ä¿®æ”¹] Header ä½œä¸º itemï¼Œé¡¶éƒ¨ç”± Header è‡ªèº«å¤„ç†
                        //  [ä¿®å¤] åŠ¨æ€åº•éƒ¨ padding
                        bottom = when {
                            useSideNavigation -> navBarHeight + 8.dp
                            isBottomBarFloating -> 100.dp
                            bottomBarVisible -> 64.dp + navBarHeight + 20.dp
                            else -> navBarHeight + 8.dp
                        },
                        start = 8.dp,
                        end = 8.dp
                    ),
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier
                        .fillMaxSize()
                        .then(
                            if (useSideNavigation) {
                                Modifier.responsiveContentWidth(maxWidth = 1000.dp)
                            } else {
                                Modifier
                            }
                        )
                ) {
                    // [æ–°å¢] éª¨æ¶å±çŠ¶æ€ä¸‹çš„ Header
                    item(span = { GridItemSpan(gridColumns) }) {
                        iOSHomeHeader(
                            scrollOffset = 0f,
                            user = state.user,
                            onAvatarClick = { if (state.user.isLogin) onProfileClick() else onAvatarClick() },
                            onSettingsClick = onSettingsClick,
                            onSearchClick = onSearchClick,
                            categoryIndex = displayedTabIndex,
                            onCategorySelected = { index ->
                                viewModel.updateDisplayedTabIndex(index)
                                val category = HomeCategory.entries[index]
                                when (category) {
                                    HomeCategory.ANIME -> onBangumiClick(1)
                                    HomeCategory.MOVIE -> onBangumiClick(2)
                                    else -> viewModel.switchCategory(category)
                                }
                            },
                            onPartitionClick = onPartitionClick,
                            isScrollingUp = true,
                            hazeState = null, // [Fix] Temporarily disable to stop crash
                            isRefreshing = isRefreshing,
                            pullProgress = 0f // [Fix] Outer header doesn't track inner pull state
                        )
                    }

                    // ğŸ“± [å¹³æ¿é€‚é…] æ ¹æ®åˆ—æ•°åŠ¨æ€ç”Ÿæˆéª¨æ¶å±æ•°é‡
                    items(gridColumns * 4) { index ->
                        VideoCardSkeleton(index = index)
                    }
                }
            } else if (state.error != null && 
                ((state.currentCategory == HomeCategory.LIVE && state.liveRooms.isEmpty()) ||
                 (state.currentCategory != HomeCategory.LIVE && state.videos.isEmpty()))) {
                
                // [ä¿®æ”¹] é”™è¯¯çŠ¶æ€æ”¹ä¸º Grid å¸ƒå±€ï¼ŒåŒ…å« Header
                LazyVerticalGrid(
                    columns = GridCells.Fixed(gridColumns),
                    contentPadding = PaddingValues(top = 0.dp), // Header è‡ªå¸¦ Padding
                    modifier = Modifier.fillMaxSize()
                        // [Fix] Apply hazeSource here if needed, but for error state maybe skip or apply to grid
                        // If header is item, it can't blur grid content behind it (it moves with it).
                        // So we disable haze effect for header in error state.
                        .hazeSource(state = hazeState)
                ) {
                    // 1. Header Item
                    item(span = { GridItemSpan(gridColumns) }) {
                        iOSHomeHeader(
                            scrollOffset = 0f,
                            user = state.user,
                            onAvatarClick = { if (state.user.isLogin) onProfileClick() else onAvatarClick() },
                            onSettingsClick = onSettingsClick,
                            onSearchClick = onSearchClick,
                            categoryIndex = displayedTabIndex,
                            onCategorySelected = { index ->
                                viewModel.updateDisplayedTabIndex(index)
                                val category = HomeCategory.entries[index]
                                when (category) {
                                    HomeCategory.ANIME -> onBangumiClick(1)
                                    HomeCategory.MOVIE -> onBangumiClick(2)
                                    else -> viewModel.switchCategory(category)
                                }
                            },
                            onPartitionClick = onPartitionClick,
                            isScrollingUp = true,
                            hazeState = null, // [Fix] Temporarily disable to stop crash
                            isRefreshing = isRefreshing,
                            pullProgress = 0f // [Fix] Outer header doesn't track inner pull state
                        )
                    }

                    // 2. Error Message Item
                    item(span = { GridItemSpan(gridColumns) }) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(500.dp), // ç»™å®šé«˜åº¦ç¡®ä¿å±…ä¸­
                            contentAlignment = Alignment.Center
                        ) {
                            Column(
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.Center,
                                modifier = Modifier.padding(16.dp)
                            ) {
                                Text(
                                    text = state.error ?: "æœªçŸ¥é”™è¯¯",
                                    style = MaterialTheme.typography.bodyLarge,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                                Spacer(modifier = Modifier.height(24.dp))
                                
                                if (state.error?.contains("ç™»å½•") == true || state.error?.contains("Login") == true) {
                                    com.android.purebilibili.core.ui.BiliGradientButton(
                                        text = "å»ç™»å½•",
                                        onClick = { onProfileClick() }
                                    )
                                } else {
                                    Button(
                                        onClick = { viewModel.refresh() },
                                        colors = ButtonDefaults.buttonColors(
                                            containerColor = MaterialTheme.colorScheme.primary
                                        )
                                    ) {
                                        Text("é‡è¯•")
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                //  [æ€§èƒ½ä¼˜åŒ–] ç§»é™¤ AnimatedContent åŒ…è£¹ï¼Œå‡å°‘åˆ†ç±»åˆ‡æ¢æ—¶çš„é‡ç»„å¼€é”€
                // åŸï¼šAnimatedContent å¯¹æ•´ä¸ª Grid åšåŠ¨ç”»ï¼Œæˆæœ¬å¾ˆé«˜
                // æ–°ï¼šç›´æ¥æ¸²æŸ“ï¼Œåˆ†ç±»åˆ‡æ¢ç¬é—´å®Œæˆ
                
                // [é‡æ„] ä½¿ç”¨ HorizontalPager å®ç°çœŸæ­£çš„ Tab åˆ‡æ¢
                // val initialPage ... (Hoisted)
                // val pagerState ... (Hoisted)
                
                //  è”åŠ¨ Pager å’Œ ViewModel category: ä»…åœ¨é¡µé¢æ»‘åŠ¨åœæ­¢ï¼ˆsettledï¼‰åè§¦å‘é‡é€»è¾‘åˆ‡æ¢
                LaunchedEffect(pagerState) {
                    snapshotFlow { pagerState.settledPage }
                        .collect { page ->
                            val category = HomeCategory.entries[page]
                            if (state.currentCategory != category) {
                                viewModel.switchCategory(category)
                            }
                        }
                }
                
                //  å½“ ViewModel å¤–éƒ¨æ”¹å˜ category æ—¶ (ä¾‹å¦‚ç‚¹å‡» Tab), æ»šåŠ¨ Pager
                LaunchedEffect(state.currentCategory) {
                    val targetIndex = HomeCategory.entries.indexOf(state.currentCategory)
                    if (targetIndex >= 0 && targetIndex != pagerState.currentPage) {
                        pagerState.animateScrollToPage(targetIndex)
                    }
                }
                
                //  [Refactor] Use Box to allow overlay and proper blur nesting
                Box(modifier = Modifier.fillMaxSize()) {
                    // [Fix] Disable default overscroll (stretch) effect which causes screen shrinking
                    CompositionLocalProvider(LocalOverscrollFactory provides null) {
                        HorizontalPager(
                            state = pagerState,
                            modifier = Modifier
                                .fillMaxSize()
                                .hazeSource(state = hazeState) // [Restored] Always apply hazeSource for consistent blur
                        ) { page ->
                        val category = HomeCategory.entries[page]
                        val categoryState = state.categoryStates[category] ?: com.android.purebilibili.feature.home.CategoryContent()
                        
                        //  ç‹¬ç«‹çš„ PullToRefreshStateï¼Œé¿å…æ‰€æœ‰é¡µé¢å…±äº«ä¸€ä¸ªçŠ¶æ€å¯¼è‡´å†²çª
                        val pullRefreshState = rememberPullToRefreshState()

                        //  [æ–°å¢] ä¸‹æ‹‰å›å¼¹ç‰©ç†åŠ¨ç”»çŠ¶æ€ (Moved from outer scope)
                        val targetPullOffset = if (pullRefreshState.distanceFraction > 0) {
                            val fraction = pullRefreshState.distanceFraction.coerceAtMost(2f)
                            fraction * 0.5f 
                        } else 0f
                        
                        //  ä½¿ç”¨ animateFloatAsState åŒ…è£…åç§»é‡
                        val animatedDragOffsetFraction by androidx.compose.animation.core.animateFloatAsState(
                            targetValue = targetPullOffset,
                            animationSpec = androidx.compose.animation.core.spring(
                                dampingRatio = 0.5f,  // 0.5 = æ˜æ˜¾çš„å¼¹æ€§ (Bouncy)
                                stiffness = 350f      // 350 = ä¸­ç­‰åˆšåº¦
                            ),
                            label = "pull_bounce"
                        )

                        //  Defers calculation to graphicsLayer
                        val calculateDragOffset: androidx.compose.ui.unit.Density.() -> Float = remember(animatedDragOffsetFraction) {
                            {
                                val maxPx = 140.dp.toPx()
                                maxPx * animatedDragOffsetFraction
                            }
                        }
                        
                        //  æ¯ä¸ªé¡µé¢ç‹¬ç«‹çš„ GridState
                        //  ä½¿ç”¨ saveable è®°ä½æ»šåŠ¨ä½ç½®
                        val pageGridState = gridStates[category] ?: rememberLazyGridState()
                        
                        //  æŠŠ GridState æå‡ç»™çˆ¶çº§ç”¨äºæ§åˆ¶ Header? 
                        //  æš‚æ—¶ç®€åŒ–ï¼šHeader å›ºå®šï¼Œå†…éƒ¨æ»šåŠ¨
                        
                        PullToRefreshBox(
                            isRefreshing = isRefreshing && state.currentCategory == category,
                            onRefresh = { viewModel.refresh() },
                            state = pullRefreshState,
                            modifier = Modifier.fillMaxSize(),
                             //  iOS é£æ ¼ä¸‹æ‹‰åˆ·æ–°æŒ‡ç¤ºå™¨ (ä½äºå†…å®¹ä¸Šæ–¹)
                             indicator = {
                                iOSRefreshIndicator(
                                    state = pullRefreshState,
                                    isRefreshing = isRefreshing,
                                     modifier = Modifier
                                         .align(Alignment.TopCenter)
                                         // [ç‰©ç†ä¼˜åŒ–] æŒ‡ç¤ºå™¨è·Ÿéšæ‹–æ‹½ç§»åŠ¨ï¼Œä¿æŒåœ¨ Gap ä¸­å¤®
                                         .padding(top = listTopPadding) 
                                         .graphicsLayer {
                                            val currentDragOffset = calculateDragOffset()
                                            // [ç‰©ç†ä¼˜åŒ–] å§‹ç»ˆä¿æŒåœ¨ Header (listTopPadding) å’Œ å†…å®¹é¡¶éƒ¨ (listTopPadding + currentDragOffset) ä¹‹é—´
                                            // å…¬å¼ï¼š (currentDragOffset / 2) - (indicatorHeight / 2)
                                            // å‡è®¾æŒ‡ç¤ºå™¨é«˜åº¦çº¦ 40dp (icon + text spacing)
                                            val indicatorHeight = 40.dp.toPx()
                                            translationY = (currentDragOffset / 2f) - (indicatorHeight / 2f)
                                         }
                                         .fillMaxWidth()
                                 )
                             }
                        ) {
                             // [ç‰©ç†ä¼˜åŒ–] å†…å®¹å®¹å™¨åº”ç”¨ä¸‹æ²‰æ•ˆæœ
                             Box(
                                 modifier = Modifier
                                     .fillMaxSize()
                                     .graphicsLayer {
                                         translationY = calculateDragOffset()
                                     }
                             ) {
                             if (categoryState.isLoading && categoryState.videos.isEmpty() && categoryState.liveRooms.isEmpty()) {
                                 // Loading Skeleton per page
                                 LazyVerticalGrid(
                                     columns = GridCells.Fixed(gridColumns),
                                     contentPadding = PaddingValues(
                                         bottom = when {
                                            useSideNavigation -> navBarHeight + 8.dp
                                            isBottomBarFloating -> 100.dp
                                            bottomBarVisible -> 64.dp + navBarHeight + 20.dp
                                            else -> navBarHeight + 8.dp
                                         },
                                         start = 8.dp, end = 8.dp, top = listTopPadding // [Fix] Apply top padding to skeleton grid too
                                     ),
                                     modifier = Modifier.fillMaxSize()
                                 ) {
                                     items(10) { VideoCardSkeleton() }
                                 }
                             } else if (categoryState.error != null && categoryState.videos.isEmpty()) {
                                 // Error State per page
                                 Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                     ModernErrorState(
                                         message = categoryState.error,
                                         onRetry = { viewModel.refresh() }
                                     )
                                 }
                             } else {
                                 // Data Content
                                 HomeCategoryPageContent(
                                     category = category,
                                     categoryState = categoryState,
                                     gridState = pageGridState,
                                     gridColumns = gridColumns,
                                     contentPadding = PaddingValues(
                                         bottom = when {
                                            useSideNavigation -> navBarHeight + 8.dp
                                            isBottomBarFloating -> 100.dp
                                            bottomBarVisible -> 64.dp + navBarHeight + 20.dp
                                            else -> navBarHeight + 8.dp
                                         },
                                         start = 8.dp, end = 8.dp, top = listTopPadding 
                                     ),
                                     dissolvingVideos = state.dissolvingVideos,
                                     followingMids = state.followingMids,
                                     onVideoClick = wrappedOnVideoClick,
                                     onLiveClick = onLiveClick,
                                     onLoadMore = { viewModel.loadMore() },
                                     onDismissVideo = { viewModel.startVideoDissolve(it) },
                                     onWatchLater = { bvid, aid -> viewModel.addToWatchLater(bvid, aid) },
                                     onDissolveComplete = { viewModel.completeVideoDissolve(it) }
                                 )
                             }
                             } // Close Box wrapper
                        }
                    }
                    } // Ends CompositionLocalProvider
                }
            } // å…³é—­ PullToRefreshBox
            }  // [Fix] Add missing brace for else block
        }  // å…³é—­ hazeSource Box
        
        //  ===== Header Overlay (æ¯›ç»ç’ƒæ•ˆæœ) =====
        //  Header ç°åœ¨åœ¨å¤–å±‚ Box å†…ã€hazeSource å¤–éƒ¨ï¼Œå¯ä»¥æ­£ç¡®æ¨¡ç³Šå†…å±‚å†…å®¹
        val isSkeletonState = state.isLoading && state.videos.isEmpty() && state.liveRooms.isEmpty()
        val isErrorState = state.error != null && 
            ((state.currentCategory == HomeCategory.LIVE && state.liveRooms.isEmpty()) ||
             (state.currentCategory != HomeCategory.LIVE && state.videos.isEmpty()))

        if (!isSkeletonState && !isErrorState) {
            iOSHomeHeader(
                scrollOffset = scrollOffset,
                user = state.user,
                onAvatarClick = { if (state.user.isLogin) onProfileClick() else onAvatarClick() },
                onSettingsClick = onSettingsClick,
                onSearchClick = onSearchClick,
                categoryIndex = displayedTabIndex,
                onCategorySelected = { index ->
                    viewModel.updateDisplayedTabIndex(index)
                    val category = HomeCategory.entries[index]
                    when (category) {
                        HomeCategory.ANIME -> onBangumiClick(1)
                        HomeCategory.MOVIE -> onBangumiClick(2)
                        else -> viewModel.switchCategory(category)
                    }
                },
                onPartitionClick = onPartitionClick,
                isScrollingUp = isScrollingUp,
                hazeState = if (isHeaderBlurEnabled) hazeState else null,
                onStatusBarDoubleTap = {
                    coroutineScope.launch {
                        gridStates[state.currentCategory]?.animateScrollToItem(0)
                    }
                },
                isRefreshing = isRefreshing,
                pullProgress = 0f, // [Fix] Outer header doesn't track inner pull state
                pagerState = pagerState
            )
        }
    }  // å…³é—­å¤–å±‚ Box
    }  //  å…³é—­ scaffoldContent lambda
    // ğŸ“± [å¹³æ¿é€‚é…] å¯¼èˆªæ¨¡å¼åˆ‡æ¢åŠ¨ç”»
    // å§‹ç»ˆä½¿ç”¨ Row å¸ƒå±€ï¼Œé€šè¿‡åŠ¨ç”»æ§åˆ¶ä¾§è¾¹æ çš„æ˜¾ç¤º/éšè—
    Row(modifier = Modifier.fillMaxSize()) {
        AnimatedVisibility(
            visible = useSideNavigation,
            enter = slideInHorizontally(
                initialOffsetX = { -it },
                animationSpec = tween(300, easing = LinearOutSlowInEasing)
            ) + fadeIn(animationSpec = tween(200)),
            exit = slideOutHorizontally(
                targetOffsetX = { -it },
                animationSpec = tween(250, easing = FastOutLinearInEasing)
            ) + fadeOut(animationSpec = tween(200))
        ) {
            FrostedSideBar(
                currentItem = currentNavItem,
                onItemClick = handleNavItemClick,
                onHomeDoubleTap = {
                    coroutineScope.launch { gridStates[state.currentCategory]?.animateScrollToItem(0) }
                },
                hazeState = if (isBottomBarBlurEnabled) hazeState else null,
                visibleItems = visibleBottomBarItems,
                itemColorIndices = bottomBarItemColors,
                onToggleSidebar = onToggleNavigationMode
            )
        }

        Box(
            modifier = Modifier
                .fillMaxHeight()
                .weight(1f)
        ) {
            scaffoldContent()
        }
    }
}
