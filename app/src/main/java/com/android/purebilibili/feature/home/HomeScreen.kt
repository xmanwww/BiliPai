// æ–‡ä»¶è·¯å¾„: feature/home/HomeScreen.kt
package com.android.purebilibili.feature.home

import android.annotation.SuppressLint
import android.content.Context
import androidx.compose.animation.*
import androidx.compose.animation.core.tween
import androidx.compose.animation.core.LinearOutSlowInEasing
import androidx.compose.animation.core.FastOutLinearInEasing
import androidx.compose.foundation.ExperimentalFoundationApi //  Added
import androidx.compose.foundation.LocalOverscrollFactory // [Fix] Import for disabling overscroll (New API)
import androidx.compose.foundation.gestures.detectHorizontalDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.*
import androidx.compose.foundation.lazy.staggeredgrid.*  // ğŸŒŠ ç€‘å¸ƒæµå¸ƒå±€
import com.kyant.backdrop.backdrops.layerBackdrop // [Fix] Import for modifier
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.material3.pulltorefresh.PullToRefreshBox
import androidx.compose.material3.pulltorefresh.rememberPullToRefreshState
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.zIndex
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.graphics.luminance  //  çŠ¶æ€æ äº®åº¦è®¡ç®—
import androidx.compose.ui.input.nestedscroll.NestedScrollConnection
import androidx.compose.ui.input.nestedscroll.NestedScrollSource
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.android.purebilibili.core.theme.BiliPink
import com.android.purebilibili.feature.settings.GITHUB_URL
import com.android.purebilibili.core.store.SettingsManager //  å¼•å…¥ SettingsManager
//  ä» components åŒ…å¯¼å…¥æ‹†åˆ†åçš„ç»„ä»¶
import com.android.purebilibili.feature.home.components.BottomNavItem
import com.android.purebilibili.feature.home.components.FluidHomeTopBar
import com.android.purebilibili.feature.home.components.FrostedSideBar
import com.android.purebilibili.feature.home.components.CategoryTabRow
import com.android.purebilibili.feature.home.components.iOSHomeHeader  //  iOS å¤§æ ‡é¢˜å¤´éƒ¨
import com.android.purebilibili.feature.home.components.iOSRefreshIndicator  //  iOS ä¸‹æ‹‰åˆ·æ–°æŒ‡ç¤ºå™¨
//  ä» cards å­åŒ…å¯¼å…¥å¡ç‰‡ç»„ä»¶
import com.android.purebilibili.feature.home.components.cards.ElegantVideoCard
import com.android.purebilibili.feature.home.components.cards.LiveRoomCard
import com.android.purebilibili.feature.home.components.cards.StoryVideoCard   //  æ•…äº‹å¡ç‰‡
import com.android.purebilibili.core.ui.LoadingAnimation
import com.android.purebilibili.core.ui.VideoCardSkeleton
import com.android.purebilibili.core.ui.ErrorState as ModernErrorState
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.hazeSource
import com.android.purebilibili.core.ui.shimmer
import com.android.purebilibili.core.ui.LocalSharedTransitionScope  //  å…±äº«è¿‡æ¸¡
import com.android.purebilibili.core.ui.animation.DissolvableVideoCard  //  ç²’å­æ¶ˆæ•£åŠ¨ç”»
import com.android.purebilibili.core.ui.animation.jiggleOnDissolve      // ğŸ“³ iOS é£æ ¼æŠ–åŠ¨æ•ˆæœ
import com.android.purebilibili.core.util.responsiveContentWidth
import io.github.alexzhirkevich.cupertino.CupertinoActivityIndicator
import coil.imageLoader
import kotlinx.coroutines.launch
import kotlinx.coroutines.flow.distinctUntilChanged  //  æ€§èƒ½ä¼˜åŒ–ï¼šé˜²æ­¢é‡å¤è§¦å‘
import androidx.compose.animation.ExperimentalSharedTransitionApi  //  å…±äº«è¿‡æ¸¡å®éªŒAPI
import com.android.purebilibili.core.ui.LocalSetBottomBarVisible
import com.android.purebilibili.core.ui.LocalBottomBarVisible

import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.receiveAsFlow
import com.android.purebilibili.data.model.response.VideoItem // [Fix] Import VideoItem
import com.android.purebilibili.feature.home.components.VideoPreviewDialog // [Fix] Import VideoPreviewDialog

// [æ–°å¢] å…¨å±€å›é¡¶äº‹ä»¶é€šé“
val LocalHomeScrollChannel = compositionLocalOf<Channel<Unit>?> { null }

// [New] Global Scroll Offset for Liquid Glass Effect
// Used to pass scroll position from HomeScreen to BottomBar without causing recomposition
val LocalHomeScrollOffset = compositionLocalOf { androidx.compose.runtime.mutableFloatStateOf(0f) }

@SuppressLint("UnusedMaterial3ScaffoldPaddingParameter")
@OptIn(ExperimentalMaterial3Api::class, ExperimentalSharedTransitionApi::class, ExperimentalFoundationApi::class)
@Composable
fun HomeScreen(
    viewModel: HomeViewModel = viewModel(),
    onVideoClick: (String, Long, String) -> Unit,
    onAvatarClick: () -> Unit,
    onProfileClick: () -> Unit,
    onSettingsClick: () -> Unit,
    onSearchClick: () -> Unit,
    //  æ–°å¢ï¼šåŠ¨æ€é¡µé¢å›è°ƒ
    onDynamicClick: () -> Unit = {},
    //  æ–°å¢ï¼šå†å²è®°å½•å›è°ƒ
    onHistoryClick: () -> Unit = {},
    //  æ–°å¢ï¼šåˆ†åŒºå›è°ƒ
    onPartitionClick: () -> Unit = {},
    //  æ–°å¢ï¼šç›´æ’­ç‚¹å‡»å›è°ƒ
    onLiveClick: (Long, String, String) -> Unit = { _, _, _ -> },  // roomId, title, uname
    //  [ä¿®å¤] ç•ªå‰§/å½±è§†å›è°ƒï¼Œæ¥å—ç±»å‹å‚æ•° (1=ç•ªå‰§ 2=ç”µå½± ç­‰)
    onBangumiClick: (Int) -> Unit = {},
    //  æ–°å¢ï¼šåˆ†ç±»ç‚¹å‡»å›è°ƒï¼ˆç”¨äºæ¸¸æˆã€çŸ¥è¯†ã€ç§‘æŠ€ç­‰åˆ†ç±»ï¼Œä¼ å…¥ tid å’Œ nameï¼‰
    onCategoryClick: (Int, String) -> Unit = { _, _ -> },
    //  [æ–°å¢] åº•æ æ‰©å±•é¡¹ç›®å¯¼èˆªå›è°ƒ
    onFavoriteClick: () -> Unit = {},  // æ”¶è—é¡µé¢
    onLiveListClick: () -> Unit = {},  // ç›´æ’­åˆ—è¡¨é¡µé¢
    onWatchLaterClick: () -> Unit = {},  // ç¨åå†çœ‹é¡µé¢
    onStoryClick: () -> Unit = {},  //  [æ–°å¢] ç«–å±çŸ­è§†é¢‘
    globalHazeState: dev.chrisbanes.haze.HazeState? = null  //  [æ–°å¢] å…¨å±€åº•æ æ¨¡ç³ŠçŠ¶æ€
) {
    val state by viewModel.uiState.collectAsState()
    val isRefreshing by viewModel.isRefreshing.collectAsState()
// val pullRefreshState = rememberPullToRefreshState() // [Removed] Moved inside HorizontalPager
    val context = LocalContext.current
    //  [Refactor] Use a map of grid states for each category to support HorizontalPager
    // [Refactor] Use a map of grid states for each category to support HorizontalPager
    val gridStates = remember { mutableMapOf<HomeCategory, LazyGridState>() }
    HomeCategory.entries.forEach { category ->
        gridStates[category] = rememberLazyGridState()
    }
    val staggeredGridState = rememberLazyStaggeredGridState() // ğŸŒŠ ç€‘å¸ƒæµçŠ¶æ€
    val hazeState = remember { HazeState() }


    // [Feature] Video Preview State (Global Scope)
    val targetVideoItemState = remember { mutableStateOf<VideoItem?>(null) }
    // [Revert] Background capture removed for performance
    // val homeBackdrop = com.kyant.backdrop.backdrops.rememberLayerBackdrop()

    val coroutineScope = rememberCoroutineScope() // ç”¨äºåŒå‡»å›é¡¶åŠ¨ç”»

    // [æ–°å¢] ç›‘å¬å…¨å±€å›é¡¶äº‹ä»¶
    val scrollChannel = LocalHomeScrollChannel.current
    LaunchedEffect(scrollChannel) {
        scrollChannel?.receiveAsFlow()?.collect {
            launch {
                val gridState = gridStates[state.currentCategory]
                val isAtTop = gridState == null || (gridState.firstVisibleItemIndex == 0 && gridState.firstVisibleItemScrollOffset < 50)

                if (isAtTop) {
                    viewModel.refresh()
                } else {
                    // [æ€§èƒ½ä¼˜åŒ–] é•¿åˆ—è¡¨å›é¡¶æ€§èƒ½ä¼˜åŒ–
                    // å¦‚æœåˆ—è¡¨æ»šå¾—å¤ªè¿œï¼ˆ>12ä¸ªï¼‰ï¼Œç›´æ¥å¹³æ»‘æ»šåŠ¨ä¼šå› ä¸ºmeasureå¤ªå¤šitemå¯¼è‡´å¡é¡¿
                    // è§£å†³æ–¹æ¡ˆï¼šé€šè¿‡ scrollToItem å…ˆ"ç¬ç§»"åˆ°ç¬¬12ä¸ªä½ç½®ï¼Œå†ä»é‚£é‡Œå¹³æ»‘æ»šå›é¡¶éƒ¨
                    // è¿™æ ·æ—¢ä¿ç•™äº†å›é¡¶çš„åŠ¨æ•ˆï¼Œåˆé¿å…äº†å¤§é‡è®¡ç®—
                    if ((gridState?.firstVisibleItemIndex ?: 0) > 12) {
                        gridState?.scrollToItem(12)
                    }
                    gridState?.animateScrollToItem(0)
                }
            }
        }
    }

    // [Refactor] Hoist PagerState to be available for both Content and Header
    // ç¡®ä¿ pagerState åœ¨æ‰€æœ‰ä½œç”¨åŸŸå‡å¯è§ï¼Œä»¥ä¾¿ä¼ ç»™ iOSHomeHeader
    val initialPage = HomeCategory.entries.indexOf(state.currentCategory).coerceAtLeast(0)
    val pagerState = androidx.compose.foundation.pager.rememberPagerState(initialPage = initialPage) { HomeCategory.entries.size }
    
    // [ä¿®å¤] åˆ·æ–°æ—¶è‡ªåŠ¨æ»šå›é¡¶éƒ¨ï¼Œé˜²æ­¢ä¸‹æ‹‰ç”¨åŠ›è¿‡çŒ›å¯¼è‡´å†…å®¹åç§»
    LaunchedEffect(isRefreshing) {
        if (isRefreshing) {
            gridStates[state.currentCategory]?.animateScrollToItem(0)
        }
    }
    
    //  [æ–°å¢] JSON æ’ä»¶è¿‡æ»¤æç¤º
    val snackbarHostState = remember { SnackbarHostState() }
    val lastFilteredCount by com.android.purebilibili.core.plugin.json.JsonPluginManager.lastFilteredCount.collectAsState()
    
    //  å½“æœ‰è§†é¢‘è¢«è¿‡æ»¤æ—¶æ˜¾ç¤ºæç¤º
    LaunchedEffect(lastFilteredCount) {
        if (lastFilteredCount > 0) {
            snackbarHostState.showSnackbar(
                message = " å·²è¿‡æ»¤ $lastFilteredCount ä¸ªè§†é¢‘",
                duration = SnackbarDuration.Short
            )
        }
    }
    
    //  [åŸ‹ç‚¹] é¡µé¢æµè§ˆè¿½è¸ª
    LaunchedEffect(Unit) {
        com.android.purebilibili.core.util.AnalyticsHelper.logScreenView("HomeScreen")
    }
    
    //  [åŸ‹ç‚¹] åˆ†ç±»åˆ‡æ¢è¿½è¸ª
    LaunchedEffect(state.currentCategory) {
        com.android.purebilibili.core.util.AnalyticsHelper.logCategoryView(
            categoryName = state.currentCategory.label,
            categoryId = state.currentCategory.tid
        )
    }

    // [New] Broadcast Scroll Offset for Liquid Glass Effect & Parallax
    // Create the state here and provide it
    val globalScrollOffsetState = remember { androidx.compose.runtime.mutableFloatStateOf(0f) }

    LaunchedEffect(state.currentCategory, gridStates) { // Re-launch when category changes
        // Use a simple timer loop or snapshotFlow to poll scroll state to avoid heavy recomposition
        // We only need rough updates for the shader wave effect
        val gridState = gridStates[state.currentCategory] ?: return@LaunchedEffect
        snapshotFlow { 
            // Calculate an approximate absolute scroll pixel value
            gridState.firstVisibleItemIndex * 500f + gridState.firstVisibleItemScrollOffset
        }.collect { offset ->
            globalScrollOffsetState.floatValue = offset
        }
    }
    
    //  [å½©è›‹] å½©è›‹å¼€å…³è®¾ç½®
    val easterEggEnabled by SettingsManager.getEasterEggEnabled(context).collectAsState(initial = true)
    var showEasterEggDialog by remember { mutableStateOf(false) }
    
    //  [å½©è›‹] ä¸‹æ‹‰åˆ·æ–°æˆåŠŸåæ˜¾ç¤ºè¶£å‘³æç¤ºï¼ˆä»…åœ¨å¼€å…³å¼€å¯æ—¶ï¼‰
    LaunchedEffect(state.refreshKey, easterEggEnabled) {
        val message = state.refreshMessage
        if (message != null && state.refreshKey > 0 && easterEggEnabled) {
            val result = snackbarHostState.showSnackbar(
                message = message,
                actionLabel = "å…³é—­å½©è›‹",
                duration = SnackbarDuration.Short
            )
            if (result == SnackbarResult.ActionPerformed) {
                showEasterEggDialog = true
            }
        }
    }
    
    //  [å½©è›‹] å…³é—­ç¡®è®¤å¯¹è¯æ¡†
    if (showEasterEggDialog) {
        androidx.compose.material3.AlertDialog(
            onDismissRequest = { showEasterEggDialog = false },
            title = { 
                Text(
                    "å…³é—­è¶£å‘³æç¤ºï¼Ÿ", 
                    color = MaterialTheme.colorScheme.onSurface
                ) 
            },
            text = { 
                Text(
                    "å…³é—­åä¸‹æ‹‰åˆ·æ–°å°†ä¸å†æ˜¾ç¤ºè¶£å‘³æ¶ˆæ¯ã€‚\n\nä½ å¯ä»¥åœ¨ã€Œè®¾ç½®ã€ä¸­éšæ—¶é‡æ–°å¼€å¯ã€‚",
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                ) 
            },
            confirmButton = {
                androidx.compose.material3.TextButton(
                    onClick = {
                        coroutineScope.launch {
                            SettingsManager.setEasterEggEnabled(context, false)
                        }
                        showEasterEggDialog = false
                    }
                ) { Text("å…³é—­å½©è›‹", color = MaterialTheme.colorScheme.error) }
            },
            dismissButton = {
                androidx.compose.material3.TextButton(
                    onClick = { showEasterEggDialog = false }
                ) { Text("ä¿ç•™å½©è›‹", color = MaterialTheme.colorScheme.primary) }
            },
            containerColor = MaterialTheme.colorScheme.surface
        )
    }
    
    //  [ä¿®å¤] ç¡®ä¿é¦–é¡µæ˜¾ç¤ºæ—¶ WindowInsets é…ç½®æ­£ç¡®ï¼Œé˜²æ­¢ä»è§†é¢‘é¡µè¿”å›æ—¶å¸ƒå±€è·³åŠ¨
    val view = androidx.compose.ui.platform.LocalView.current
    SideEffect {
        val window = (view.context as? android.app.Activity)?.window ?: return@SideEffect
        // ä¿æŒè¾¹åˆ°è¾¹æ˜¾ç¤ºï¼ˆä¸ VideoDetailScreen ä¸€è‡´ï¼‰
        androidx.core.view.WindowCompat.setDecorFitsSystemWindows(window, false)
    }

    //  [æ€§èƒ½ä¼˜åŒ–] åˆå¹¶é¦–é¡µè®¾ç½®ä¸ºå•ä¸€ Flowï¼Œå‡å°‘ 6 ä¸ª collectAsState â†’ 1 ä¸ª
    val homeSettings by SettingsManager.getHomeSettings(context).collectAsState(
        initial = com.android.purebilibili.core.store.HomeSettings()
    )
    
    // è§£æ„è®¾ç½®å€¼ï¼ˆé¿å…æ¯æ¬¡è®¿é—®éƒ½è§¦å‘é‡ç»„ï¼‰
    val displayMode = homeSettings.displayMode
    val isBottomBarFloating = homeSettings.isBottomBarFloating
    val bottomBarLabelMode = homeSettings.bottomBarLabelMode
    val isHeaderBlurEnabled = homeSettings.isHeaderBlurEnabled
    val isBottomBarBlurEnabled = homeSettings.isBottomBarBlurEnabled
    val crashTrackingConsentShown = homeSettings.crashTrackingConsentShown
    val cardAnimationEnabled = homeSettings.cardAnimationEnabled      //  å¡ç‰‡è¿›åœºåŠ¨ç”»å¼€å…³
    val cardTransitionEnabled = homeSettings.cardTransitionEnabled    //  å¡ç‰‡è¿‡æ¸¡åŠ¨ç”»å¼€å…³
    
    //  [æ–°å¢] åº•æ å¯è§é¡¹ç›®é…ç½®
    val orderedVisibleTabIds by SettingsManager.getOrderedVisibleTabs(context).collectAsState(
        initial = listOf("HOME", "DYNAMIC", "HISTORY", "PROFILE")
    )
    // å°†å­—ç¬¦ä¸² ID è½¬æ¢ä¸º BottomNavItem æšä¸¾
    val visibleBottomBarItems = remember(orderedVisibleTabIds) {
        orderedVisibleTabIds.mapNotNull { id ->
            try { BottomNavItem.valueOf(id) } catch (e: Exception) { null }
        }
    }
    
    //  [æ–°å¢] åº•æ é¡¹ç›®é¢œè‰²é…ç½®
    val bottomBarItemColors by SettingsManager.getBottomBarItemColors(context).collectAsState(initial = emptyMap<String, Int>())

    
    //  ğŸ“ [å¹³æ¿é€‚é…] æ ¹æ®å±å¹•å°ºå¯¸å’Œå±•ç¤ºæ¨¡å¼åŠ¨æ€è®¾ç½®ç½‘æ ¼åˆ—æ•°
    // æ•…äº‹å¡ç‰‡(1)å’Œæ²‰æµ¸æ¨¡å¼(2)éœ€è¦å•åˆ—å…¨å®½ï¼Œç½‘æ ¼(0)ä½¿ç”¨åŒåˆ—
    val windowSizeClass = com.android.purebilibili.core.util.LocalWindowSizeClass.current
    val contentWidth = if (windowSizeClass.isExpandedScreen) {
        minOf(windowSizeClass.widthDp, 1280.dp)
    } else {
        windowSizeClass.widthDp
    }
    
    // æ˜¯å¦ä¸ºå•åˆ—æ¨¡å¼ (Story or Cinematic)
    val isSingleColumnMode = displayMode == 1
    
    val adaptiveColumns = remember(contentWidth, displayMode) {
        val minColumnWidth = if (isSingleColumnMode) 280.dp else 180.dp // å•åˆ—æ¨¡å¼ç»™æ›´å®½çš„åŸºå‡†
        val maxColumns = if (isSingleColumnMode) 2 else 6
        val columns = (contentWidth / minColumnWidth).toInt()
        columns.coerceIn(1, maxColumns)
    }
    val gridColumns = if (windowSizeClass.isExpandedScreen) {
        adaptiveColumns
    } else {
        com.android.purebilibili.core.util.rememberResponsiveValue(
            compact = if (isSingleColumnMode) 1 else 2,  // æ‰‹æœºï¼šå•åˆ—æ¨¡å¼1åˆ—ï¼Œå…¶ä»–2åˆ—
            medium = if (isSingleColumnMode) 2 else 3    // ä¸­ç­‰å®½åº¦ï¼šå•åˆ—æ¨¡å¼2åˆ—ï¼Œå…¶å®ƒ3åˆ—
        )
    }
    
    
    //   [å¹³æ¿å¯¼èˆªåˆ‡æ¢] ç”¨æˆ·åå¥½è®¾ç½®
    val tabletUseSidebar by SettingsManager.getTabletUseSidebar(context).collectAsState(initial = false)
    
    //  ğŸ“ [å¤§å±é€‚é…] å¹³æ¿å¯¼èˆªæ¨¡å¼ï¼šæ ¹æ®ç”¨æˆ·åå¥½å†³å®š
    // ä»…åœ¨å¹³æ¿ä¸”ç”¨æˆ·é€‰æ‹©äº†ä¾§è¾¹æ æ—¶ä½¿ç”¨ä¾§è¾¹å¯¼èˆª
    val useSideNavigation = windowSizeClass.isExpandedScreen && tabletUseSidebar
    
    //  ğŸ“± [åˆ‡æ¢å¯¼èˆªæ¨¡å¼] å¤„ç†å‡½æ•°
    val onToggleNavigationMode: () -> Unit = {
        coroutineScope.launch {
            SettingsManager.setTabletUseSidebar(context, !tabletUseSidebar)
        }
    }

    //  [ä¿®å¤] æ¢å¤çŠ¶æ€æ æ ·å¼ï¼šç¡®ä¿ä»è§†é¢‘è¯¦æƒ…é¡µè¿”å›åçŠ¶æ€æ æ­£ç¡®
    // å½“ä½¿ç”¨æ»‘åŠ¨åŠ¨ç”»æ—¶ï¼ŒTheme.kt çš„ SideEffect å¯èƒ½ä¸ä¼šé‡æ–°æ‰§è¡Œ
    val backgroundColor = MaterialTheme.colorScheme.background
    val isLightBackground = remember(backgroundColor) { backgroundColor.luminance() > 0.5f }
    
    if (!view.isInEditMode) {
        SideEffect {
            val window = (context as? android.app.Activity)?.window ?: return@SideEffect
            val insetsController = androidx.core.view.WindowCompat.getInsetsController(window, view)
            //  æ ¹æ®èƒŒæ™¯äº®åº¦è®¾ç½®çŠ¶æ€æ å›¾æ ‡é¢œè‰²
            insetsController.isAppearanceLightStatusBars = isLightBackground
            //  [ä¿®å¤] å¯¼èˆªæ ä¹Ÿéœ€è¦æ ¹æ®èƒŒæ™¯äº®åº¦è®¾ç½®å›¾æ ‡é¢œè‰²
            insetsController.isAppearanceLightNavigationBars = isLightBackground
            //  ç¡®ä¿çŠ¶æ€æ å¯è§ä¸”é€æ˜
            insetsController.show(androidx.core.view.WindowInsetsCompat.Type.statusBars())
            window.statusBarColor = android.graphics.Color.TRANSPARENT
            //  [ä¿®å¤] å¯¼èˆªæ ä¹Ÿè®¾ä¸ºé€æ˜ï¼Œç¡®ä¿åº•æ éšè—æ—¶æ‰‹åŠ¿åŒºåŸŸæ²‰æµ¸
            window.navigationBarColor = android.graphics.Color.TRANSPARENT
        }
    }

    val density = LocalDensity.current
    val navBarHeight = WindowInsets.navigationBars.getBottom(density).let { with(density) { it.toDp() } }
    
    val bottomBarHeight = if (isBottomBarFloating) {
        84.dp + navBarHeight  // 72dp(æ é«˜åº¦) + 12dp(åº•éƒ¨è¾¹è·)
    } else {
        64.dp + navBarHeight  // 64dp(Dockedæ¨¡å¼)
    }

    //  [ä¿®å¤] åŠ¨æ€è®¡ç®—å†…å®¹é¡¶éƒ¨è¾¹è·ï¼Œé˜²æ­¢è¢«å¤´éƒ¨é®æŒ¡
    val statusBarHeight = WindowInsets.statusBars.asPaddingValues().calculateTopPadding()
    val listTopPadding = statusBarHeight + 120.dp  // [è°ƒæ•´] ä¼˜åŒ–é¡¶éƒ¨é—´è· (110 -> 120) å¢åŠ å‘¼å¸æ„Ÿ

    val prefs = remember { context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE) }
    
    //  å½“å‰é€‰ä¸­çš„å¯¼èˆªé¡¹
    var currentNavItem by remember { mutableStateOf(BottomNavItem.HOME) }

    // ç»Ÿä¸€å¯¼èˆªç‚¹å‡»é€»è¾‘ï¼ˆåº•æ /ä¾§æ å¤ç”¨ï¼‰
    val handleNavItemClick: (BottomNavItem) -> Unit = { item ->
        currentNavItem = item
        when (item) {
            BottomNavItem.HOME -> {
                coroutineScope.launch { 
                    val gridState = gridStates[state.currentCategory]
                    val isAtTop = gridState == null || (gridState.firstVisibleItemIndex == 0 && gridState.firstVisibleItemScrollOffset < 50)
                    
                    if (isAtTop) {
                        viewModel.refresh()
                    } else {
                        // [æ€§èƒ½ä¼˜åŒ–] é€»è¾‘åŒä¸Šï¼Œå¦‚æœå¤ªè¿œå…ˆç¬ç§»å›æ¥
                        if ((gridState?.firstVisibleItemIndex ?: 0) > 12) {
                            gridState?.scrollToItem(12)
                        }
                        gridState?.animateScrollToItem(0) 
                    } 
                }
            }
            BottomNavItem.DYNAMIC -> onDynamicClick()
            BottomNavItem.HISTORY -> onHistoryClick()
            BottomNavItem.PROFILE -> onProfileClick()
            BottomNavItem.FAVORITE -> onFavoriteClick()
            BottomNavItem.LIVE -> onLiveListClick()
            BottomNavItem.WATCHLATER -> onWatchLaterClick()
            BottomNavItem.STORY -> onStoryClick()
            BottomNavItem.SETTINGS -> onSettingsClick()
        }
    }
    
    //  [æ–°å¢] åº•æ æ˜¾ç¤ºæ¨¡å¼è®¾ç½®
    val bottomBarVisibilityMode by SettingsManager.getBottomBarVisibilityMode(context).collectAsState(
        initial = SettingsManager.BottomBarVisibilityMode.ALWAYS_VISIBLE
    )
    
    //  [Refactor] ä½¿ç”¨å…¨å±€ CompositionLocal æ§åˆ¶åº•æ å¯è§æ€§
    val setBottomBarVisible = LocalSetBottomBarVisible.current
    val isGlobalBottomBarVisible = LocalBottomBarVisible.current
    // å…¼å®¹ä»£ç ï¼šä¸ºäº†æœ€å°åŒ–æ”¹åŠ¨ï¼Œå°† bottomBarVisible æŒ‡å‘å…¨å±€çŠ¶æ€
    // æ³¨æ„ï¼šè¿™é‡Œçš„ bottomBarVisible ç°åœ¨æ˜¯åªè¯»çš„ï¼Œä¿®æ”¹å¿…é¡»é€šè¿‡ setBottomBarVisible
    val bottomBarVisible = isGlobalBottomBarVisible
    
    //  [ä¿®å¤] è·Ÿè¸ªæ˜¯å¦æ­£åœ¨å¯¼èˆªåˆ°/ä»è§†é¢‘é¡µ - å¿…é¡»åœ¨ LaunchedEffect ä¹‹å‰å£°æ˜
    var isVideoNavigating by remember { mutableStateOf(false) }
    
    //  [æ–°å¢] æ»šåŠ¨æ–¹å‘æ£€æµ‹çŠ¶æ€ï¼ˆç”¨äºä¸Šæ»‘éšè—æ¨¡å¼ï¼‰
    var lastScrollOffset by remember { mutableIntStateOf(0) }
    var lastFirstVisibleItem by remember { mutableIntStateOf(0) }
    
    //  [æ–°å¢] æ»šåŠ¨æ–¹å‘æ£€æµ‹é€»è¾‘
    LaunchedEffect(state.currentCategory, bottomBarVisibilityMode, useSideNavigation) {
        if (useSideNavigation) {
            setBottomBarVisible(false)
            return@LaunchedEffect
        }
        if (bottomBarVisibilityMode != SettingsManager.BottomBarVisibilityMode.SCROLL_HIDE) {
            // éæ»šåŠ¨éšè—æ¨¡å¼æ—¶ï¼Œæ ¹æ®è®¾ç½®å†³å®šåº•æ å¯è§æ€§
            setBottomBarVisible(bottomBarVisibilityMode == SettingsManager.BottomBarVisibilityMode.ALWAYS_VISIBLE)
            return@LaunchedEffect
        }
        
        // ä¸Šæ»‘éšè—æ¨¡å¼ï¼šç›‘å¬æ»šåŠ¨æ–¹å‘
        val currentGridState = gridStates[state.currentCategory] ?: return@LaunchedEffect
        snapshotFlow {
            Pair(currentGridState.firstVisibleItemIndex, currentGridState.firstVisibleItemScrollOffset)
        }
        .distinctUntilChanged()
        .collect { (firstVisibleItem, scrollOffset) ->
            // è§†é¢‘å¯¼èˆªæœŸé—´ä¸å¤„ç†æ»šåŠ¨éšè—
            if (isVideoNavigating) return@collect
            
            // æ»šåŠ¨åˆ°é¡¶éƒ¨æ—¶å§‹ç»ˆæ˜¾ç¤º
            if (firstVisibleItem == 0 && scrollOffset < 100) {
                setBottomBarVisible(true)
            } else {
                // è®¡ç®—æ»šåŠ¨æ–¹å‘
                val isScrollingDown = when {
                    firstVisibleItem > lastFirstVisibleItem -> true
                    firstVisibleItem < lastFirstVisibleItem -> false
                    else -> scrollOffset > lastScrollOffset + 200 // [UXä¼˜åŒ–] å¢å¤§è¿Ÿæ»é˜ˆå€¼ (30 -> 200) é˜²æ­¢å¾®å°æŠ–åŠ¨
                }
                val isScrollingUp = when {
                    firstVisibleItem < lastFirstVisibleItem -> true
                    firstVisibleItem > lastFirstVisibleItem -> false
                    else -> scrollOffset < lastScrollOffset - 200 // [UXä¼˜åŒ–] å¢å¤§è¿Ÿæ»é˜ˆå€¼
                }
                
                if (isScrollingDown) setBottomBarVisible(false)
                else if (isScrollingUp) setBottomBarVisible(true)
            }
            
            lastFirstVisibleItem = firstVisibleItem
            lastScrollOffset = scrollOffset
        }
    }
    
    // [Feature] Sticky Header Logic via NestedScrollConnection
    // Max collapse depends on setting: 
    // If enabled: Search Bar (52.dp) + Tabs (44.dp)
    // If disabled: Only Search Bar (52.dp)
    val searchBarHeightDp = 52.dp
    val tabRowHeightDp = 44.dp
    val searchBarHeightPx = with(density) { searchBarHeightDp.toPx() }
    val tabRowHeightPx = with(density) { tabRowHeightDp.toPx() }
    
    val isHeaderCollapseEnabled = homeSettings.isHeaderCollapseEnabled
    
    val headerMaxOffsetPx = if (isHeaderCollapseEnabled) {
        searchBarHeightPx + tabRowHeightPx
    } else {
        0f // [Fix] Fixed Header when setting is disabled (No collapse at all)
    }

    var headerOffsetHeightPx by remember { mutableFloatStateOf(0f) }

    val nestedScrollConnection = remember(headerMaxOffsetPx) {
        object : NestedScrollConnection {
            override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {
                val delta = available.y
                val newOffset = headerOffsetHeightPx + delta
                headerOffsetHeightPx = newOffset.coerceIn(-headerMaxOffsetPx, 0f)
                return Offset.Zero // Do not consume scroll, let list scroll too
            }
        }
    }
    
    // Reset header when switching categories or toggling setting
    LaunchedEffect(state.currentCategory, isHeaderCollapseEnabled) {
        headerOffsetHeightPx = 0f
    }
    
    // [Removed] Legacy snapshotFlow logic for isHeaderVisible
    val isHeaderVisible = true // Always "visible" in terms of layout presence, managed by offset now
    
    // [Fix Bug 2] é¦–é¡µä¸Šæ»‘æœªè§¦å‘éšè—æ—¶åˆ‡æ¢ Tab å¯¼è‡´åº•æ çªå…€æ¶ˆå¤±çš„é—®é¢˜
    // ç›‘å¬ currentCategory å˜åŒ–ï¼Œå¦‚æœæ–° Tab å¤„äºé¡¶éƒ¨ï¼Œå¼ºåˆ¶æ˜¾ç¤ºåº•æ 
    LaunchedEffect(state.currentCategory) {
        val currentGridState = gridStates[state.currentCategory]
        if (currentGridState == null || (currentGridState.firstVisibleItemIndex == 0 && currentGridState.firstVisibleItemScrollOffset < 200)) {
            setBottomBarVisible(true) 
        }
    }
    
    //  [ä¿®å¤] ç”¨äºå–æ¶ˆå»¶è¿Ÿåç¨‹çš„ Job å¼•ç”¨
    var bottomBarRestoreJob by remember { mutableStateOf<kotlinx.coroutines.Job?>(null) }
    
    //  åŒ…è£… onVideoClickï¼šç‚¹å‡»è§†é¢‘æ—¶å…ˆéšè—åº•æ å†å¯¼èˆª
    val wrappedOnVideoClick: (String, Long, String) -> Unit = remember(onVideoClick) {
        { bvid, cid, cover ->
            //  å–æ¶ˆä¹‹å‰çš„æ¢å¤åç¨‹ï¼Œé˜²æ­¢ç«æ€æ¡ä»¶
            bottomBarRestoreJob?.cancel()
            bottomBarRestoreJob = null
            
            setBottomBarVisible(false)  //  è§¦å‘åº•æ ä¸‹æ»‘åŠ¨ç”»
            isVideoNavigating = true  //  æ ‡è®°æ­£åœ¨å¯¼èˆªåˆ°è§†é¢‘
            onVideoClick(bvid, cid, cover)
        }
    }
    
    //  [ä¿®å¤] ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸäº‹ä»¶æ§åˆ¶åº•æ å¯è§æ€§
    // ON_START: æ¢å¤åº•æ ï¼ˆä»…åœ¨ä»è§†é¢‘é¡µè¿”å›æ—¶ï¼‰
    // ON_STOP: éšè—åº•æ ï¼ˆå¯¼èˆªåˆ°å…¶ä»–é¡µé¢æ—¶ï¼Œé¿å…å½±å“å¯¼èˆªæ åŒºåŸŸï¼‰
    val lifecycleOwner = androidx.compose.ui.platform.LocalLifecycleOwner.current
    DisposableEffect(lifecycleOwner, useSideNavigation) {
        if (useSideNavigation) {
            return@DisposableEffect onDispose { }
        }
        val observer = androidx.lifecycle.LifecycleEventObserver { _, event ->
            when (event) {
                androidx.lifecycle.Lifecycle.Event.ON_START -> {
                    //  å…³é”®ä¿®å¤ï¼šåªåœ¨åº•æ å½“å‰éšè—æ—¶æ‰æ¢å¤å¯è§
                    if (!bottomBarVisible && isVideoNavigating) {
                        //  [åŒæ­¥åŠ¨ç”»] å»¶è¿Ÿåå†æ˜¾ç¤ºåº•æ ï¼Œè®©è¿›å…¥åŠ¨ç”»ä¸å¡ç‰‡è¿”å›åŠ¨ç”»åŒæ­¥
                        //  [ä¼˜åŒ–] å°†å»¶è¿Ÿå¢åŠ åˆ° 360ms (ç•¥å¤§äºè½¬åœºåŠ¨ç”» 350ms)ï¼Œé˜²æ­¢åœ¨åŠ¨ç”»è¿‡ç¨‹ä¸­ä¿®æ”¹ Padding å¯¼è‡´åˆ—è¡¨é‡æ’å¡é¡¿
                        bottomBarRestoreJob = kotlinx.coroutines.MainScope().launch {
                            kotlinx.coroutines.delay(360)  // ç­‰å¾…è¿”å›åŠ¨ç”»ç»“æŸ
                            setBottomBarVisible(true)
                            // å»¶è¿Ÿé‡ç½®å¯¼èˆªçŠ¶æ€ï¼Œç¡®ä¿è¿›å…¥åŠ¨ç”»å®Œæˆ
                            kotlinx.coroutines.delay(200)
                            isVideoNavigating = false
                        }
                    } else if (!bottomBarVisible && !isVideoNavigating) {
                        //  [æ–°å¢] ä»è®¾ç½®ç­‰éè§†é¢‘é¡µé¢è¿”å›æ—¶ï¼Œç«‹å³æ˜¾ç¤ºåº•æ ï¼ˆæ— å»¶è¿Ÿï¼‰
                        setBottomBarVisible(true)
                    }
                }
                androidx.lifecycle.Lifecycle.Event.ON_STOP -> {
                    //  [ä¿®å¤] ç§»é™¤æ­¤å¤„éšè—åº•æ çš„é€»è¾‘
                    //  é˜²æ­¢åˆ‡æ¢åˆ°å…¶ä»–Tabï¼ˆå¦‚åŠ¨æ€/å†å²ï¼‰æ—¶åº•æ æ¶ˆå¤±
                    bottomBarRestoreJob?.cancel()
                    bottomBarRestoreJob = null
                    // setBottomBarVisible(false) // REMOVED
                }
                else -> { /* å…¶ä»–äº‹ä»¶ä¸å¤„ç† */ }
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            bottomBarRestoreJob?.cancel()
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
    
    //  [ä¿®å¤] ä½¿ç”¨ ViewModel ä¸­çš„æ ‡ç­¾é¡µæ˜¾ç¤ºç´¢å¼•ï¼ˆè·¨å¯¼èˆªä¿æŒï¼‰
    // å½“ç”¨æˆ·æ»‘åŠ¨åˆ°ç‰¹æ®Šåˆ†ç±»æ—¶ï¼Œæ ‡ç­¾é¡µä½ç½®æ›´æ–°ï¼Œä½†å†…å®¹åˆ†ç±»ä¿æŒä¸å˜
    val displayedTabIndex = state.displayedTabIndex
    
    //  [ä¿®å¤] ä½¿ç”¨ rememberSaveable è®°ä½æœ¬æ¬¡ä¼šè¯ä¸­æ˜¯å¦å·²å¤„ç†è¿‡å¼¹çª—ï¼ˆé˜²æ­¢å¯¼èˆªåé‡æ–°æ˜¾ç¤ºï¼‰
    var consentDialogHandled by rememberSaveable { mutableStateOf(false) }
    var showConsentDialog by remember { mutableStateOf(false) }
    
    //  æ£€æŸ¥æ¬¢è¿å¼¹çª—æ˜¯å¦å·²æ˜¾ç¤ºè¿‡ï¼ˆç¡®ä¿å¼¹çª—é¡ºåºæ˜¾ç¤ºï¼Œä¸ä¼šåŒæ—¶å‡ºç°ï¼‰
    val welcomePrefs = remember { context.getSharedPreferences("app_welcome", Context.MODE_PRIVATE) }
    val welcomeAlreadyShown = welcomePrefs.getBoolean("first_launch_shown", false)
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºå¼¹çª—ï¼ˆæ¬¢è¿å¼¹çª—å·²æ˜¾ç¤ºè¿‡ ä¸” åŒæ„å¼¹çª—å°šæœªæ˜¾ç¤ºè¿‡ ä¸” æœ¬æ¬¡ä¼šè¯æœªå¤„ç†è¿‡ï¼‰
    LaunchedEffect(crashTrackingConsentShown) {
        if (welcomeAlreadyShown && !crashTrackingConsentShown && !consentDialogHandled) {
            showConsentDialog = true
        }
    }
    
    // æ˜¾ç¤ºå¼¹çª—
    if (showConsentDialog) {
        com.android.purebilibili.feature.home.components.CrashTrackingConsentDialog(
            onDismiss = { 
                showConsentDialog = false
                consentDialogHandled = true  // æ ‡è®°ä¸ºå·²å¤„ç†
            }
        )
    }
    
    //  è®¡ç®—æ»šåŠ¨åç§»é‡ç”¨äºå¤´éƒ¨åŠ¨ç”» -  ä¼˜åŒ–ï¼šé‡åŒ–å‡å°‘é‡ç»„
    //  è®¡ç®—æ»šåŠ¨åç§»é‡ç”¨äºå¤´éƒ¨åŠ¨ç”» -  ä¼˜åŒ–ï¼šé‡åŒ–å‡å°‘é‡ç»„
    val scrollOffset by remember {
        derivedStateOf {
            val currentGridState = gridStates[state.currentCategory]
            if (currentGridState == null) return@derivedStateOf 0f
            
            val firstVisibleItem = currentGridState.firstVisibleItemIndex
            if (firstVisibleItem == 0) {
                //  ç›´æ¥ä½¿ç”¨åŸå§‹åç§»é‡ï¼Œé¿å…é‡åŒ–å¯¼è‡´çš„è·³å˜
                currentGridState.firstVisibleItemScrollOffset.toFloat()
            } else 1000f
        }
    }
    
    //  æ»šåŠ¨æ–¹å‘ï¼ˆç®€åŒ–ç‰ˆ - ä¸å†éœ€è¦å¤æ‚æ£€æµ‹ï¼Œå› ä¸ºæ ‡ç­¾é¡µåªåœ¨é¡¶éƒ¨æ˜¾ç¤ºï¼‰
    val isScrollingUp = true  // ä¿ç•™å‚æ•°å…¼å®¹æ€§

    val shouldLoadMore by remember {
        derivedStateOf {
            val currentGridState = gridStates[state.currentCategory]
            if (currentGridState == null) return@derivedStateOf false

            val layoutInfo = currentGridState.layoutInfo
            val totalItems = layoutInfo.totalItemsCount
            val lastVisibleItemIndex = layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0
            totalItems > 0 && lastVisibleItemIndex >= totalItems - 4 && !state.isLoading && !isRefreshing
        }
    }
    LaunchedEffect(shouldLoadMore) { if (shouldLoadMore) viewModel.loadMore() }
    
    //  [æ€§èƒ½ä¼˜åŒ–] å›¾ç‰‡é¢„åŠ è½½ - æå‰åŠ è½½å³å°†æ˜¾ç¤ºçš„è§†é¢‘å°é¢
    // ğŸ“‰ [çœæµé‡] çœæµé‡æ¨¡å¼ä¸‹ç¦ç”¨é¢„åŠ è½½
    val isDataSaverActive = remember {
        com.android.purebilibili.core.store.SettingsManager.isDataSaverActive(context)
    }
    
    LaunchedEffect(state.currentCategory, isDataSaverActive) {
        // ğŸ“‰ çœæµé‡æ¨¡å¼ä¸‹è·³è¿‡é¢„åŠ è½½
        if (isDataSaverActive) return@LaunchedEffect
        
        val currentGridState = gridStates[state.currentCategory] ?: return@LaunchedEffect
        
        snapshotFlow { currentGridState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0 }
            .distinctUntilChanged()  //  åªåœ¨ç´¢å¼•å˜åŒ–æ—¶è§¦å‘
            .collect { lastVisibleIndex ->
                val videos = state.videos
                val preloadStart = (lastVisibleIndex + 1).coerceAtMost(videos.size)
                val preloadEnd = (lastVisibleIndex + 6).coerceAtMost(videos.size)  //  å‡å°‘é¢„åŠ è½½æ•°é‡
                
                if (preloadStart < preloadEnd) {
                    for (i in preloadStart until preloadEnd) {
                        val imageUrl = videos.getOrNull(i)?.pic ?: continue
                        val request = coil.request.ImageRequest.Builder(context)
                            .data(com.android.purebilibili.core.util.FormatUtils.fixImageUrl(imageUrl))
                            .size(360, 225)  //  é¢„åŠ è½½ä¹Ÿä½¿ç”¨é™åˆ¶å°ºå¯¸
                            .memoryCachePolicy(coil.request.CachePolicy.ENABLED)
                            .diskCachePolicy(coil.request.CachePolicy.ENABLED)
                            .build()
                        context.imageLoader.enqueue(request)
                    }
                }
            }
    }


    //  PullToRefreshBox è‡ªåŠ¨å¤„ç†ä¸‹æ‹‰åˆ·æ–°é€»è¾‘
    
    //  [å·²ç§»é™¤] ç‰¹æ®Šåˆ†ç±»ï¼ˆANIME, MOVIEç­‰ï¼‰ä¸å†åœ¨é¦–é¡µåˆ‡æ¢ï¼Œç›´æ¥å¯¼èˆªåˆ°ç‹¬ç«‹é¡µé¢
    
    //  [ä¿®å¤] å¦‚æœå½“å‰åœ¨ç›´æ’­-å…³æ³¨åˆ†ç±»ä¸”åˆ—è¡¨ä¸ºç©ºï¼Œè¿”å›æ—¶å…ˆåˆ‡æ¢åˆ°çƒ­é—¨ï¼Œå†åˆ‡æ¢åˆ°æ¨è
    val isEmptyLiveFollowed = state.currentCategory == HomeCategory.LIVE && 
                               state.liveSubCategory == LiveSubCategory.FOLLOWED &&
                               state.liveRooms.isEmpty() && 
                               !state.isLoading
    androidx.activity.compose.BackHandler(enabled = isEmptyLiveFollowed) {
        // åˆ‡æ¢åˆ°çƒ­é—¨ç›´æ’­
        viewModel.switchLiveSubCategory(LiveSubCategory.POPULAR)
    }

    //  [ä¿®å¤] å¦‚æœå½“å‰åœ¨ç›´æ’­åˆ†ç±»ï¼ˆéå…³æ³¨ç©ºåˆ—è¡¨æƒ…å†µï¼‰ï¼Œè¿”å›æ—¶åˆ‡æ¢åˆ°æ¨è
    val isLiveCategoryNotHome = state.currentCategory == HomeCategory.LIVE && !isEmptyLiveFollowed
    androidx.activity.compose.BackHandler(enabled = isLiveCategoryNotHome) {
        viewModel.switchCategory(HomeCategory.RECOMMEND)
    }
    
// [Removed] Animation logic moved inside HorizontalPager where the active state exists
    
    // æŒ‡ç¤ºå™¨ä½ç½®é€»è¾‘ä¹Ÿç§»å…¥ graphicsLayer
    
    val scaffoldContent: @Composable () -> Unit = {

    Scaffold(
        //  [æ–°å¢] JSON æ’ä»¶è¿‡æ»¤æç¤º
        snackbarHost = {
            SnackbarHost(
                hostState = snackbarHostState,
                modifier = Modifier.padding(
                    bottom = when {
                        useSideNavigation -> navBarHeight + 8.dp
                        isBottomBarFloating -> 100.dp
                        else -> 80.dp
                    }
                )
            )
        },
        //  [ä¿®å¤] ç¦ç”¨ Scaffold é»˜è®¤çš„ contentWindowInsetsï¼Œé˜²æ­¢åº•éƒ¨å‡ºç°ç™½è‰²å¡«å……
        contentWindowInsets = WindowInsets(0),
        containerColor = MaterialTheme.colorScheme.background
    ) { padding ->
        //  [é‡æ„] å®ç°çœŸæ­£çš„æ¯›ç»ç’ƒæ•ˆæœ
        // å¤–å±‚ Box åŒ…å«ï¼š1) hazeSource å†…å®¹å±‚  2) Header overlay å±‚
        // Header åœ¨ hazeSource å¤–éƒ¨ï¼Œå¯ä»¥æ­£ç¡®æ¨¡ç³Šå†…å±‚å†…å®¹
        Box(
            modifier = Modifier.fillMaxSize()
        ) {
            CompositionLocalProvider(LocalHomeScrollOffset provides globalScrollOffsetState) {

            // ===== å†…å®¹å±‚ (hazeSource) =====
            
            // [Feature] Animate content up when Tabs collapse
            // [Optimized] Use direct offset from NestedScroll
            // Note: If we translate content up, we might see the gap? 
            // Actually, standard behavior is: Header translates UP (clips), content scrolls naturally.
            // We usually DO NOT translate the whole content box unless we want to pull it up.
            // Since we use standard list with padding, we let the list handle its own scroll.
            // But we can translate the *Tab Row* or Header container inside iOSHomeHeader.
            // So we don't need `contentTranslationY` here anymore for the whole Box.

            // [ä¿®å¤] å¦‚æœæœ‰å…¨å±€ hazeStateï¼ŒåŒæ—¶åº”ç”¨ä¸¤ä¸ª hazeSource
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .nestedScroll(nestedScrollConnection) // [Feature] Attach scroll connection
                    //.graphicsLayer { translationY = contentTranslationY.toPx() } // [Removed]
                    // [Revert] Capture for Liquid Glass TopBar removed

                    // [Revert] Capture for Liquid Glass TopBar removed
                    // .run { ... }
                    // [Fix] Move local hazeSource deeper to avoid drawing hierarchy crash
                    // .hazeSource(state = hazeState) 
                    .then(if (globalHazeState != null) Modifier.hazeSource(state = globalHazeState) else Modifier)  // å…¨å±€ hazeSource - åº•æ ä½¿ç”¨
            ) {
            //  [Restored] Always render Pager. Loading/Error states are handled per-page internally.
            //  This prevents the Pager from being destroyed during category switches or loading states.
                
            //  [Best Practice] ä½¿ç”¨ InteractionSource åŒºåˆ†ç”¨æˆ·æ“ä½œå’Œä»£ç æ»šåŠ¨
            //  åªæœ‰åœ¨ç”¨æˆ·å‘ç”Ÿè¿‡æ‹–æ‹½/æŒ‰å‹è¡Œä¸ºåçš„ settling æ‰æ˜¯ç”¨æˆ·åˆ‡æ¢ï¼Œå¦åˆ™å¯èƒ½æ˜¯ä»£ç è§¦å‘çš„æ»šåŠ¨
            var isUserAction by remember { mutableStateOf(false) }

                //  ç›‘å¬ç”¨æˆ·äº¤äº’
                LaunchedEffect(pagerState) {
                    pagerState.interactionSource.interactions.collect { interaction ->
                        if (interaction is androidx.compose.foundation.interaction.DragInteraction.Start) {
                            isUserAction = true
                        }
                    }
                }

                //  è”åŠ¨ Pager -> ViewModel
                //  ä»…å½“ isUserAction ä¸º true æ—¶æ‰å…è®¸ Pager é©±åŠ¨ ViewModel å˜æ›´
                LaunchedEffect(pagerState) {
                    snapshotFlow { pagerState.settledPage }
                        .collect { page ->
                            if (isUserAction) {
                                val category = HomeCategory.entries[page]
                                if (state.currentCategory != category) {
                                    viewModel.switchCategory(category)
                                }
                                // é‡ç½®æ ‡è®°ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡æ‰‹åŠ¿
                                isUserAction = false
                            }
                        }
                }
                
                //  è”åŠ¨ ViewModel -> Pager
                //  å½“ç‚¹å‡» Tab æ—¶è§¦å‘ï¼Œæ­¤æ—¶ isUserAction ä¸º falseï¼Œä¸ä¼šåå‘è§¦å‘
                LaunchedEffect(state.currentCategory) {
                    val targetIndex = HomeCategory.entries.indexOf(state.currentCategory)
                    if (targetIndex >= 0 && targetIndex != pagerState.currentPage) {
                        pagerState.animateScrollToPage(targetIndex)
                    }
                }
                
                //  [Refactor] Use Box to allow overlay and proper blur nesting
                // [æ–°å¢] Video Preview State (Long Press)
    // [Move] Preview Dialog is now an overlay at the end of the Box
    // if (previewVideoItem != null) { ... } // Removed

    Box(modifier = Modifier.fillMaxSize()) {
                    // [Fix] Re-enabled default overscroll for better feedback
                        HorizontalPager(
                            state = pagerState,
                            beyondViewportPageCount = 1, // [Optimization] Preload adjacent pages to prevent swipe lag
                            modifier = Modifier
                                .fillMaxSize()
                                .hazeSource(state = hazeState), // [Restored] Always apply hazeSource for consistent blur
                            key = { index -> HomeCategory.entries[index].ordinal }
                        ) { page ->
                        val category = HomeCategory.entries[page]
                        val categoryState = state.categoryStates[category] ?: com.android.purebilibili.feature.home.CategoryContent()
                        
                        //  ç‹¬ç«‹çš„ PullToRefreshStateï¼Œé¿å…æ‰€æœ‰é¡µé¢å…±äº«ä¸€ä¸ªçŠ¶æ€å¯¼è‡´å†²çª
                        val pullRefreshState = rememberPullToRefreshState()

                        //  [æ–°å¢] ä¸‹æ‹‰å›å¼¹ç‰©ç†åŠ¨ç”»çŠ¶æ€ (Moved from outer scope)
                        val targetPullOffset = if (pullRefreshState.distanceFraction > 0) {
                            val fraction = pullRefreshState.distanceFraction.coerceAtMost(2f)
                            fraction * 0.5f 
                        } else 0f
                        
                        //  ä½¿ç”¨ animateFloatAsState åŒ…è£…åç§»é‡
                        val animatedDragOffsetFraction by androidx.compose.animation.core.animateFloatAsState(
                            targetValue = targetPullOffset,
                            animationSpec = androidx.compose.animation.core.spring(
                                dampingRatio = 0.5f,  // 0.5 = æ˜æ˜¾çš„å¼¹æ€§ (Bouncy)
                                stiffness = 350f      // 350 = ä¸­ç­‰åˆšåº¦
                            ),
                            label = "pull_bounce"
                        )

                        //  Defers calculation to graphicsLayer
                        val calculateDragOffset: androidx.compose.ui.unit.Density.() -> Float = remember(animatedDragOffsetFraction) {
                            {
                                val maxPx = 140.dp.toPx()
                                maxPx * animatedDragOffsetFraction
                            }
                        }
                        
                        //  æ¯ä¸ªé¡µé¢ç‹¬ç«‹çš„ GridState
                        //  ä½¿ç”¨ saveable è®°ä½æ»šåŠ¨ä½ç½®
                        val pageGridState = gridStates[category] ?: rememberLazyGridState()
                        
                        //  æŠŠ GridState æå‡ç»™çˆ¶çº§ç”¨äºæ§åˆ¶ Header? 
                        
                        PullToRefreshBox(
                            isRefreshing = isRefreshing && state.currentCategory == category,
                            onRefresh = { viewModel.refresh() },
                            state = pullRefreshState,
                            modifier = Modifier.fillMaxSize(),
                             //  iOS é£æ ¼ä¸‹æ‹‰åˆ·æ–°æŒ‡ç¤ºå™¨ (ä½äºå†…å®¹ä¸Šæ–¹)
                             indicator = {
                                iOSRefreshIndicator(
                                    state = pullRefreshState,
                                    isRefreshing = isRefreshing,
                                     modifier = Modifier
                                         .align(Alignment.TopCenter)
                                         // [ç‰©ç†ä¼˜åŒ–] æŒ‡ç¤ºå™¨è·Ÿéšæ‹–æ‹½ç§»åŠ¨ï¼Œä¿æŒåœ¨ Gap ä¸­å¤®
                                         .padding(top = listTopPadding) 
                                         .graphicsLayer {
                                            val currentDragOffset = calculateDragOffset()
                                            // [ç‰©ç†ä¼˜åŒ–] å§‹ç»ˆä¿æŒåœ¨ Header (listTopPadding) å’Œ å†…å®¹é¡¶éƒ¨ (listTopPadding + currentDragOffset) ä¹‹é—´
                                            // å…¬å¼ï¼š (currentDragOffset / 2) - (indicatorHeight / 2)
                                            // å‡è®¾æŒ‡ç¤ºå™¨é«˜åº¦çº¦ 40dp (icon + text spacing)
                                            val indicatorHeight = 40.dp.toPx()
                                            translationY = (currentDragOffset / 2f) - (indicatorHeight / 2f)
                                         }
                                         .fillMaxWidth()
                                 )
                             }
                        ) {
                             // [ç‰©ç†ä¼˜åŒ–] å†…å®¹å®¹å™¨åº”ç”¨ä¸‹æ²‰æ•ˆæœ
                             Box(
                                 modifier = Modifier
                                     .fillMaxSize()
                                     .graphicsLayer {
                                         translationY = calculateDragOffset()
                                     }
                             ) {
                             if (categoryState.isLoading && categoryState.videos.isEmpty() && categoryState.liveRooms.isEmpty()) {
                                 // Loading Skeleton per page
                                 LazyVerticalGrid(
                                     columns = GridCells.Fixed(gridColumns),
                                     contentPadding = PaddingValues(
                                         bottom = when {
                                            useSideNavigation -> navBarHeight + 8.dp
                                            isBottomBarFloating -> 100.dp
                                            bottomBarVisible -> 64.dp + navBarHeight + 20.dp
                                            else -> navBarHeight + 8.dp
                                         },
                                         start = 8.dp, end = 8.dp, top = listTopPadding // [Fix] Apply top padding to skeleton grid too
                                     ),
                                     horizontalArrangement = Arrangement.spacedBy(10.dp),
                                     verticalArrangement = Arrangement.spacedBy(10.dp),
                                     modifier = Modifier.fillMaxSize()
                                 ) {
                                     items(10) { index -> VideoCardSkeleton(index = index) }
                                 }
                             } else if (categoryState.error != null && categoryState.videos.isEmpty()) {
                                 // Error State per page
                                 Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                     ModernErrorState(
                                         message = categoryState.error,
                                         onRetry = { viewModel.refresh() }
                                     )
                                 }
                             } else {
                                 // Data Content
                                 HomeCategoryPageContent(
                                     category = category,
                                     categoryState = categoryState,
                                     gridState = pageGridState,
                                     gridColumns = gridColumns,
                                     contentPadding = PaddingValues(
                                         bottom = when {
                                            useSideNavigation -> navBarHeight + 8.dp
                                            isBottomBarFloating -> 100.dp
                                            bottomBarVisible -> 64.dp + navBarHeight + 20.dp
                                            else -> navBarHeight + 8.dp
                                         },
                                         start = 8.dp, end = 8.dp, top = listTopPadding 
                                     ),
                                     dissolvingVideos = state.dissolvingVideos,
                                     followingMids = state.followingMids,
                                     onVideoClick = wrappedOnVideoClick,
                                     onLiveClick = onLiveClick,
                                     onLoadMore = { viewModel.loadMore() },
                                     onDismissVideo = { viewModel.startVideoDissolve(it) },
                                     onWatchLater = { bvid, aid -> viewModel.addToWatchLater(bvid, aid) },
                                     onDissolveComplete = { viewModel.completeVideoDissolve(it) },
                                     longPressCallback = { targetVideoItemState.value = it } // [Feature] Pass callback
                                 )
                             }
                             } // Close Box wrapper
                        }
                    }
                }
            } // Close Box wrapperfreshBox
        }  // å…³é—­ hazeSource Box
        
        //  ===== Header Overlay (æ¯›ç»ç’ƒæ•ˆæœ) =====
        //  Header ç°åœ¨åœ¨å¤–å±‚ Box å†…ã€hazeSource å¤–éƒ¨ï¼Œå¯ä»¥æ­£ç¡®æ¨¡ç³Šå†…å±‚å†…å®¹
        val isSkeletonState = state.isLoading && state.videos.isEmpty() && state.liveRooms.isEmpty()
        val isErrorState = state.error != null && 
            ((state.currentCategory == HomeCategory.LIVE && state.liveRooms.isEmpty()) ||
             (state.currentCategory != HomeCategory.LIVE && state.videos.isEmpty()))

        //  [Restored] Header å§‹ç»ˆæ˜¾ç¤ºï¼Œä¸å†éš Loading/Error çŠ¶æ€éšè—
        //  è¿™ä¿è¯äº† Tab æŒ‡ç¤ºå™¨çŠ¶æ€çš„è¿ç»­æ€§ï¼Œé˜²æ­¢æ¶ˆå¤±æˆ–é‡ç½®
        
        // Calculate parameters based on scroll
        // 1. Search Bar Collapse (First phase)
        val searchCollapseAmount = headerOffsetHeightPx.coerceAtLeast(-searchBarHeightPx)
        val currentSearchHeight = searchBarHeightDp + with(density) { searchCollapseAmount.toDp() }
        val searchAlpha = (1f + (searchCollapseAmount / searchBarHeightPx)).coerceIn(0f, 1f)
        
        // 2. Tab Row Collapse (Second phase, only if enabled)
        // Starts after Search Bar is fully collapsed (-52dp)
        val tabCollapseStart = -searchBarHeightPx
        val tabCollapseAmount = (headerOffsetHeightPx - tabCollapseStart).coerceAtMost(0f)
        
        val currentTabHeight = if (headerOffsetHeightPx < tabCollapseStart && isHeaderCollapseEnabled) {
             tabRowHeightDp + with(density) { tabCollapseAmount.toDp() }
        } else {
             tabRowHeightDp
        }
        val tabAlpha = if (headerOffsetHeightPx < tabCollapseStart && isHeaderCollapseEnabled) {
            (1f + (tabCollapseAmount / tabRowHeightPx)).coerceIn(0f, 1f)
        } else 1f
        
        iOSHomeHeader(
            searchBarHeight = currentSearchHeight,
            searchBarAlpha = searchAlpha,
            tabContainerHeight = currentTabHeight, // [Feature] Dynamic Tab Height
            tabAlpha = tabAlpha,                   // [Feature] Dynamic Tab Alpha
            user = state.user,
            onAvatarClick = { if (state.user.isLogin) onProfileClick() else onAvatarClick() },
            onSettingsClick = onSettingsClick,
            onSearchClick = onSearchClick,
            categoryIndex = displayedTabIndex,
            onCategorySelected = { index ->
                viewModel.updateDisplayedTabIndex(index)
                val category = HomeCategory.entries[index]
                when (category) {
                    HomeCategory.ANIME -> onBangumiClick(1)
                    HomeCategory.MOVIE -> onBangumiClick(2)
                    else -> viewModel.switchCategory(category)
                }
            },
            onPartitionClick = onPartitionClick,
            // isScrollingUp = isHeaderVisible, // [Removed] logic moved to offset
            hazeState = if (isHeaderBlurEnabled) hazeState else null,
            onStatusBarDoubleTap = {
                coroutineScope.launch {
                    gridStates[state.currentCategory]?.animateScrollToItem(0)
                    headerOffsetHeightPx = 0f // [Refinement] Reset header on double tap
                }
            },
            isRefreshing = isRefreshing,
            pullProgress = 0f, // [Fix] Outer header doesn't track inner pull state
            pagerState = pagerState,
            // [Revert] backdrop removed
            // backdrop = homeBackdrop,
            homeSettings = homeSettings
        )
        // [Feature] Video Preview Overlay with Animation
        androidx.compose.animation.AnimatedVisibility(
            visible = targetVideoItemState.value != null,
            enter = fadeIn(tween(200)) + scaleIn(initialScale = 0.9f, animationSpec = tween(200, easing = androidx.compose.animation.core.FastOutSlowInEasing)),
            exit = fadeOut(tween(200)) + scaleOut(targetScale = 0.9f, animationSpec = tween(200, easing = androidx.compose.animation.core.FastOutSlowInEasing)),
            modifier = Modifier.fillMaxSize().zIndex(100f) // Ensure on top
        ) {
            val item = targetVideoItemState.value
            if (item != null) {
                com.android.purebilibili.feature.home.components.VideoPreviewDialog(
                    video = item,
                    onDismiss = { targetVideoItemState.value = null },
                    onPlay = {
                     // 1. Log click
                     wrappedOnVideoClick(item.bvid, item.id, item.pic)
                     // 2. Clear preview state
                     targetVideoItemState.value = null
                },
                onWatchLater = {
                    viewModel.addToWatchLater(item.bvid, item.aid)
                    targetVideoItemState.value = null
                },
                onShare = {
                   val shareIntent = android.content.Intent(android.content.Intent.ACTION_SEND).apply {
                        type = "text/plain"
                        putExtra(android.content.Intent.EXTRA_TEXT, "ã€${item.title}ã€‘ https://www.bilibili.com/video/${item.bvid}")
                    }
                    val chooser = android.content.Intent.createChooser(shareIntent, "åˆ†äº«è§†é¢‘")
                    if (context !is android.app.Activity) {
                        chooser.addFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK)
                    }
                    context.startActivity(chooser)
                    targetVideoItemState.value = null
                },
                onNotInterested = {
                    viewModel.markNotInterested(item.bvid)
                    targetVideoItemState.value = null
                },
                onGetPreviewUrl = { bvid, cid ->
                    viewModel.getPreviewVideoUrl(bvid, cid)
                },
                hazeState = hazeState
            )
            }
        }

    }  // å…³é—­ outer Box

    }  // å…³é—­ Scaffold lambda
    }  //  å…³é—­ scaffoldContent lambda
    // ğŸ“± [å¹³æ¿é€‚é…] å¯¼èˆªæ¨¡å¼åˆ‡æ¢åŠ¨ç”»
    // å§‹ç»ˆä½¿ç”¨ Row å¸ƒå±€ï¼Œé€šè¿‡åŠ¨ç”»æ§åˆ¶ä¾§è¾¹æ çš„æ˜¾ç¤º/éšè—
    Row(modifier = Modifier.fillMaxSize()) {
        AnimatedVisibility(
            visible = useSideNavigation,
            enter = slideInHorizontally(
                initialOffsetX = { -it },
                animationSpec = tween(300, easing = LinearOutSlowInEasing)
            ) + fadeIn(animationSpec = tween(200)),
            exit = slideOutHorizontally(
                targetOffsetX = { -it },
                animationSpec = tween(250, easing = FastOutLinearInEasing)
            ) + fadeOut(animationSpec = tween(200))
        ) {
            FrostedSideBar(
                currentItem = currentNavItem,
                onItemClick = handleNavItemClick,
                onHomeDoubleTap = {
                    coroutineScope.launch { gridStates[state.currentCategory]?.animateScrollToItem(0) }
                },
                hazeState = if (isBottomBarBlurEnabled) hazeState else null,
                visibleItems = visibleBottomBarItems,
                itemColorIndices = bottomBarItemColors,
                onToggleSidebar = onToggleNavigationMode
            )
        }

        Box(
            modifier = Modifier
                .fillMaxHeight()
                .weight(1f)
        ) {
            scaffoldContent()
        }
    }
}
