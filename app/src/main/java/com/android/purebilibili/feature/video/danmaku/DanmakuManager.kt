// æ–‡ä»¶è·¯å¾„: feature/video/danmaku/DanmakuManager.kt
package com.android.purebilibili.feature.video.danmaku

import android.content.Context
import android.graphics.Typeface
import android.util.Log
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import com.android.purebilibili.core.plugin.DanmakuItem
import com.android.purebilibili.core.plugin.DanmakuPlugin
import com.android.purebilibili.core.plugin.DanmakuStyle
import com.android.purebilibili.core.plugin.PluginManager
import com.android.purebilibili.core.plugin.json.JsonPluginManager
import com.bytedance.danmaku.render.engine.DanmakuView
import com.bytedance.danmaku.render.engine.control.DanmakuController
import com.bytedance.danmaku.render.engine.data.DanmakuData
import com.bytedance.danmaku.render.engine.render.draw.text.TextData
import com.bytedance.danmaku.render.engine.touch.IItemClickListener
import com.bytedance.danmaku.render.engine.utils.LAYER_TYPE_BOTTOM_CENTER
import com.bytedance.danmaku.render.engine.utils.LAYER_TYPE_SCROLL
import com.bytedance.danmaku.render.engine.utils.LAYER_TYPE_TOP_CENTER
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.math.abs

/**
 * å¼¹å¹•ç®¡ç†å™¨ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰
 * 
 * ä½¿ç”¨ ByteDance DanmakuRenderEngine é‡æ„
 * 
 * è´Ÿè´£ï¼š
 * 1. åŠ è½½å’Œè§£æå¼¹å¹•æ•°æ®
 * 2. ä¸ ExoPlayer åŒæ­¥å¼¹å¹•æ’­æ”¾
 * 3. ç®¡ç†å¼¹å¹•è§†å›¾ç”Ÿå‘½å‘¨æœŸ
 * 
 * ä½¿ç”¨å•ä¾‹æ¨¡å¼ç¡®ä¿æ¨ªç«–å±åˆ‡æ¢æ—¶ä¿æŒå¼¹å¹•çŠ¶æ€
 */
class DanmakuManager private constructor(
    private val context: Context,
    private var scope: CoroutineScope
) {
    companion object {
        private const val TAG = "DanmakuManager"
        
        @Volatile
        private var instance: DanmakuManager? = null
        
        /**
         * è·å–å•ä¾‹å®ä¾‹
         */
        fun getInstance(context: Context, scope: CoroutineScope): DanmakuManager {
            return instance ?: synchronized(this) {
                instance ?: DanmakuManager(context.applicationContext, scope).also { 
                    instance = it 
                    Log.d(TAG, " DanmakuManager instance created")
                }
            }
        }
        
        /**
         * æ›´æ–° CoroutineScopeï¼ˆç”¨äºé…ç½®å˜åŒ–æ—¶ï¼‰
         */
        fun updateScope(scope: CoroutineScope) {
            instance?.updateScopeInternal(scope)
        }
        
        /**
         * é‡Šæ”¾å•ä¾‹å®ä¾‹
         */
        fun clearInstance() {
            instance?.release()
            instance = null
            Log.d(TAG, " DanmakuManager instance cleared")
        }
    }
    
    // è§†å›¾å’Œæ§åˆ¶å™¨
    private var danmakuView: DanmakuView? = null
    private var controller: DanmakuController? = null
    private var player: ExoPlayer? = null
    private var playerListener: Player.Listener? = null
    private var loadJob: Job? = null
    private var syncJob: Job? = null  // âš™ï¸ [æ¼‚ç§»ä¿®å¤] å®šæœŸæ£€æµ‹æ¼‚ç§»
    
    // å¼¹å¹•çŠ¶æ€
    private var isPlaying = false
    private var isLoading = false
    private var danmakuClickListener: ((String, Long, Long, Boolean) -> Unit)? = null
    
    // ç¼“å­˜è§£æåçš„å¼¹å¹•æ•°æ®ï¼ˆæ¨ªç«–å±åˆ‡æ¢æ—¶å¤ç”¨ï¼‰
    private var cachedDanmakuList: List<DanmakuData>? = null
    private var sourceDanmakuList: List<DanmakuData>? = null
    private var sourceAdvancedDanmakuList: List<AdvancedDanmakuData>? = null
    private var rawDanmakuList: List<DanmakuData>? = null
    // [æ–°å¢] é«˜çº§å¼¹å¹•æ•°æ®æµ
    private val _advancedDanmakuFlow = kotlinx.coroutines.flow.MutableStateFlow<List<AdvancedDanmakuData>>(emptyList())
    val advancedDanmakuFlow: kotlinx.coroutines.flow.StateFlow<List<AdvancedDanmakuData>> = _advancedDanmakuFlow.asStateFlow()
    private var cachedCid: Long = 0L
    
    //  [æ–°å¢] è®°å½•åŸå§‹å¼¹å¹•æ»šåŠ¨æ—¶é—´ï¼ˆç”¨äºå€é€ŸåŒæ­¥ï¼‰
    private var originalMoveTime: Long = 8000L  // é»˜è®¤ 8 ç§’
    private var currentVideoSpeed: Float = 1.0f
    private var pluginObserverJob: Job? = null
    private var lastDanmakuPluginUpdateToken: Long = 0L
    
    // é…ç½®
    val config = DanmakuConfig()

    init {
        startDanmakuPluginObserver()
    }
    
    // ä¾¿æ·å±æ€§è®¿é—®å™¨
    var isEnabled: Boolean
        get() = config.isEnabled
        set(value) {
            config.isEnabled = value
            if (value) show() else hide()
        }
    
    var opacity: Float
        get() = config.opacity
        set(value) {
            config.opacity = value
            applyConfigToController("opacity")
        }
    
    var fontScale: Float
        get() = config.fontScale
        set(value) {
            config.fontScale = value
            applyConfigToController("fontScale")
        }
    
    var speedFactor: Float
        get() = config.speedFactor
        set(value) {
            config.speedFactor = value
            applyConfigToController("speedFactor")
        }
    
    var displayArea: Float
        get() = config.displayAreaRatio
        set(value) {
            config.displayAreaRatio = value
            applyConfigToController("displayArea")
        }

    private fun updateScopeInternal(newScope: CoroutineScope) {
        if (scope === newScope) return
        scope = newScope
        startDanmakuPluginObserver()
    }

    private fun startDanmakuPluginObserver() {
        pluginObserverJob?.cancel()
        pluginObserverJob = scope.launch {
            PluginManager.danmakuPluginUpdateToken.collect { token ->
                if (token <= 0L || token == lastDanmakuPluginUpdateToken) return@collect
                lastDanmakuPluginUpdateToken = token

                if (isLoading || sourceDanmakuList == null) return@collect

                val rebuilt = withContext(Dispatchers.Default) {
                    rebuildDanmakuCacheFromSource("plugin_update")
                }
                if (!rebuilt) return@collect

                withContext(Dispatchers.Main) {
                    applyCachedDanmakuToController("plugin_update")
                }
            }
        }
    }

    private fun rebuildDanmakuCacheFromSource(reason: String): Boolean {
        val sourceStandard = sourceDanmakuList ?: return false
        val sourceAdvanced = sourceAdvancedDanmakuList ?: emptyList()

        val (filteredStandardList, filteredAdvancedList) =
            applyDanmakuPluginPipeline(sourceStandard, sourceAdvanced)

        if (filteredStandardList.isEmpty() && filteredAdvancedList.isEmpty()) {
            cachedDanmakuList = emptyList()
            rawDanmakuList = emptyList()
            _advancedDanmakuFlow.value = emptyList()
            Log.w(TAG, " Danmaku cache rebuilt ($reason): no visible items after filtering")
            return false
        }

        rawDanmakuList = filteredStandardList

        if (config.mergeDuplicates) {
            val (mergedStandard, mergedAdvanced) = DanmakuMerger.merge(filteredStandardList)
            cachedDanmakuList = mergedStandard
            _advancedDanmakuFlow.value = filteredAdvancedList + mergedAdvanced
        } else {
            cachedDanmakuList = filteredStandardList
            _advancedDanmakuFlow.value = filteredAdvancedList
        }

        Log.w(
            TAG,
            " Danmaku cache rebuilt ($reason): standard=${cachedDanmakuList?.size ?: 0}, advanced=${_advancedDanmakuFlow.value.size}"
        )
        return true
    }

    private fun applyCachedDanmakuToController(reason: String) {
        val currentPos = player?.currentPosition ?: 0L
        val list = cachedDanmakuList ?: emptyList()
        if (list.isEmpty()) {
            controller?.clear()
            isPlaying = false
            Log.w(TAG, " applyCachedDanmakuToController($reason): cleared (empty list)")
            return
        }

        controller?.setData(list, 0)
        controller?.invalidateView()
        controller?.start(currentPos)

        if (player?.isPlaying == true && config.isEnabled) {
            isPlaying = true
        } else {
            controller?.pause()
            isPlaying = false
        }
        Log.w(TAG, " applyCachedDanmakuToController($reason): size=${list.size}, pos=${currentPos}ms")
    }

    private fun TextData.copyForPluginPipeline(): TextData {
        val copied = if (this is WeightedTextData) {
            WeightedTextData().also {
                it.danmakuId = this.danmakuId
                it.userHash = this.userHash
                it.weight = this.weight
                it.pool = this.pool
            }
        } else {
            TextData()
        }
        copied.text = text
        copied.showAtTime = showAtTime
        copied.layerType = layerType
        copied.textColor = textColor
        copied.textSize = textSize
        copied.typeface = typeface
        return copied
    }

    private fun applyDanmakuPluginPipeline(
        standardDanmakuList: List<DanmakuData>,
        advancedDanmakuList: List<AdvancedDanmakuData>
    ): Pair<List<DanmakuData>, List<AdvancedDanmakuData>> {
        val nativePlugins = PluginManager.getEnabledDanmakuPlugins()
        val useJsonRules = JsonPluginManager.plugins.value.any { it.enabled && it.plugin.type == "danmaku" }
        if (nativePlugins.isEmpty() && !useJsonRules) {
            return Pair(standardDanmakuList, advancedDanmakuList)
        }

        var filteredStandardCount = 0
        val filteredStandard = ArrayList<DanmakuData>(standardDanmakuList.size)
        standardDanmakuList.forEach { data ->
            val sourceTextData = data as? TextData
            if (sourceTextData == null) {
                filteredStandard.add(data)
                return@forEach
            }
            val textData = sourceTextData.copyForPluginPipeline()

            val sourceItem = textData.toPluginItem()
            val filteredItem = runDanmakuFilters(sourceItem, nativePlugins, useJsonRules)
            if (filteredItem == null) {
                filteredStandardCount++
                return@forEach
            }

            val style = collectDanmakuStyle(filteredItem, nativePlugins, useJsonRules)
            textData.applyPluginResult(filteredItem, style)
            filteredStandard.add(textData)
        }

        var filteredAdvancedCount = 0
        val filteredAdvanced = ArrayList<AdvancedDanmakuData>(advancedDanmakuList.size)
        advancedDanmakuList.forEach { data ->
            val sourceItem = DanmakuItem(
                id = parseAdvancedDanmakuId(data.id),
                content = data.content,
                timeMs = data.startTimeMs,
                type = 7,
                color = data.color and 0x00FFFFFF,
                userId = ""
            )

            val filteredItem = runDanmakuFilters(sourceItem, nativePlugins, useJsonRules)
            if (filteredItem == null) {
                filteredAdvancedCount++
                return@forEach
            }

            val style = collectDanmakuStyle(filteredItem, nativePlugins, useJsonRules)
            var updated = data.copy(
                content = filteredItem.content,
                startTimeMs = filteredItem.timeMs,
                color = filteredItem.color and 0x00FFFFFF
            )
            style?.textColor?.let { color ->
                updated = updated.copy(color = color.toArgb() and 0x00FFFFFF)
            }
            if (style != null && abs(style.scale - 1.0f) > 0.01f) {
                updated = updated.copy(
                    fontSize = (updated.fontSize * style.scale).coerceIn(8f, 120f)
                )
            }
            filteredAdvanced.add(updated)
        }

        if (filteredStandardCount > 0 || filteredAdvancedCount > 0) {
            Log.w(
                TAG,
                " Danmaku plugin filter applied: standard -$filteredStandardCount, advanced -$filteredAdvancedCount"
            )
        }

        return Pair(filteredStandard, filteredAdvanced)
    }

    private fun TextData.toPluginItem(): DanmakuItem {
        val weighted = this as? WeightedTextData
        val currentColor = textColor ?: 0xFFFFFF
        return DanmakuItem(
            id = weighted?.danmakuId ?: 0L,
            content = text.orEmpty(),
            timeMs = showAtTime,
            type = mapLayerTypeToDanmakuType(layerType),
            color = currentColor and 0x00FFFFFF,
            userId = weighted?.userHash.orEmpty()
        )
    }

    private fun TextData.applyPluginResult(item: DanmakuItem, style: DanmakuStyle?) {
        text = item.content
        showAtTime = item.timeMs
        layerType = mapDanmakuTypeToLayerType(item.type)
        textColor = (item.color and 0x00FFFFFF) or 0xFF000000.toInt()

        style?.textColor?.let { color -> textColor = color.toArgb() }
        if (style != null && abs(style.scale - 1.0f) > 0.01f) {
            val currentSize = textSize ?: 25f
            val baseSize = if (currentSize > 0f) currentSize else 25f
            textSize = (baseSize * style.scale).coerceIn(12f, 96f)
        }
        typeface = if (style?.bold == true) Typeface.DEFAULT_BOLD else Typeface.DEFAULT
    }

    private fun runDanmakuFilters(
        item: DanmakuItem,
        nativePlugins: List<DanmakuPlugin>,
        useJsonRules: Boolean
    ): DanmakuItem? {
        var current = item
        nativePlugins.forEach { plugin ->
            val filtered = try {
                plugin.filterDanmaku(current)
            } catch (e: Exception) {
                Log.e(TAG, " Danmaku plugin filter failed: ${plugin.name}", e)
                current
            }
            if (filtered == null) return null
            current = filtered
        }

        if (useJsonRules) {
            val shouldShow = try {
                JsonPluginManager.shouldShowDanmaku(current)
            } catch (e: Exception) {
                Log.e(TAG, " JSON danmaku rule filter failed", e)
                true
            }
            if (!shouldShow) return null
        }

        return current
    }

    private fun collectDanmakuStyle(
        item: DanmakuItem,
        nativePlugins: List<DanmakuPlugin>,
        useJsonRules: Boolean
    ): DanmakuStyle? {
        var style: DanmakuStyle? = null
        nativePlugins.forEach { plugin ->
            val next = try {
                plugin.styleDanmaku(item)
            } catch (e: Exception) {
                Log.e(TAG, " Danmaku plugin style failed: ${plugin.name}", e)
                null
            }
            style = mergeDanmakuStyle(style, next)
        }

        if (useJsonRules) {
            val next = try {
                JsonPluginManager.getDanmakuStyle(item)
            } catch (e: Exception) {
                Log.e(TAG, " JSON danmaku rule style failed", e)
                null
            }
            style = mergeDanmakuStyle(style, next)
        }

        return style
    }

    private fun mergeDanmakuStyle(base: DanmakuStyle?, incoming: DanmakuStyle?): DanmakuStyle? {
        if (base == null) return incoming
        if (incoming == null) return base
        return DanmakuStyle(
            textColor = incoming.textColor ?: base.textColor,
            borderColor = incoming.borderColor ?: base.borderColor,
            backgroundColor = incoming.backgroundColor ?: base.backgroundColor,
            bold = base.bold || incoming.bold,
            scale = if (abs(incoming.scale - 1.0f) > 0.01f) incoming.scale else base.scale
        )
    }

    private fun mapLayerTypeToDanmakuType(layerType: Int): Int = when (layerType) {
        LAYER_TYPE_BOTTOM_CENTER -> 4
        LAYER_TYPE_TOP_CENTER -> 5
        else -> 1
    }

    private fun mapDanmakuTypeToLayerType(type: Int): Int = when (type) {
        4 -> LAYER_TYPE_BOTTOM_CENTER
        5 -> LAYER_TYPE_TOP_CENTER
        else -> LAYER_TYPE_SCROLL
    }

    private fun parseAdvancedDanmakuId(rawId: String): Long {
        return rawId.toLongOrNull()
            ?: rawId.filter { it.isDigit() }.toLongOrNull()
            ?: 0L
    }


    /**
     *  æ‰¹é‡æ›´æ–°å¼¹å¹•è®¾ç½®ï¼ˆå®æ—¶ç”Ÿæ•ˆï¼‰
     */
    fun updateSettings(
        opacity: Float = this.opacity,
        fontScale: Float = this.fontScale,
        speed: Float = this.speedFactor,
        displayArea: Float = this.displayArea,
        mergeDuplicates: Boolean = config.mergeDuplicates
    ) {
        val mergeChanged = config.mergeDuplicates != mergeDuplicates
        
        config.opacity = opacity
        config.fontScale = fontScale
        config.speedFactor = speed
        config.displayAreaRatio = displayArea
        config.mergeDuplicates = mergeDuplicates
        
        if (mergeChanged) {
            applyConfigToController("merge_changed")
        } else {
            applyConfigToController("batch")
        }
    }

    /**
     * åº”ç”¨å¼¹å¹•é…ç½®åˆ° Controllerï¼Œå¹¶åŒæ­¥å€é€ŸåŸºå‡†
     *  [ä¿®å¤] fontScale/displayArea æ”¹å˜æ—¶é‡æ–°è®¾ç½®æ•°æ®ï¼Œè®©æ–°é…ç½®ç”Ÿæ•ˆ
     */
    private fun applyConfigToController(reason: String) {
        controller?.let { ctrl ->
            val viewHeight = danmakuView?.height ?: 0
            config.applyTo(ctrl.config, viewHeight)

            // è®°å½•è®¾ç½®åçš„åŸºå‡†æ»šåŠ¨æ—¶é—´ï¼Œä¾›å€é€ŸåŒæ­¥ä½¿ç”¨
            originalMoveTime = ctrl.config.scroll.moveTime

            // è‹¥è§†é¢‘é 1.0xï¼Œåˆ™æŒ‰å€é€Ÿè°ƒæ•´å¼¹å¹•æ»šåŠ¨æ—¶é—´
            if (currentVideoSpeed != 1.0f) {
                ctrl.config.scroll.moveTime = (originalMoveTime / currentVideoSpeed).toLong()
            }

            //  [å…³é”®ä¿®å¤] fontScale/displayArea/viewHeight æ”¹å˜æ—¶ï¼Œéœ€è¦é‡æ–°è®¾ç½®å¼¹å¹•æ•°æ®
            // å› ä¸ºå¼•æ“çš„ config.text.size åªå¯¹æ–°å¼¹å¹•ç”Ÿæ•ˆï¼Œå·²æ˜¾ç¤ºçš„å¼¹å¹•ä¸ä¼šæ›´æ–°
            if (reason == "fontScale" || reason == "displayArea" || reason == "batch" || reason == "resize" || reason == "merge_changed") {
                // å¦‚æœæ˜¯åˆå¹¶çŠ¶æ€æ”¹å˜ï¼Œéœ€è¦é‡æ–°è®¡ç®— cachedList
                if (reason == "merge_changed") {
                    rebuildDanmakuCacheFromSource("merge_changed")
                }
            
                cachedDanmakuList?.let { list ->
                    val currentPos = player?.currentPosition ?: 0L
                    Log.w(TAG, " Re-applying danmaku data after $reason change at ${currentPos}ms")
                    ctrl.setData(list, 0)
                    ctrl.start(currentPos)
                    if (player?.isPlaying != true) {
                        ctrl.pause()
                    }
                }
            } else {
                ctrl.invalidateView()
            }
            
            Log.w(
                TAG,
                " Config applied ($reason): opacity=${config.opacity}, fontScale=${config.fontScale}, " +
                    "speed=${config.speedFactor}, area=${config.displayAreaRatio}, " +
                    "baseMoveTime=$originalMoveTime, videoSpeed=$currentVideoSpeed, " +
                    "moveTime=${ctrl.config.scroll.moveTime}"
            )
        }
    }
    
    //  [æ–°å¢] è®°å½•ä¸Šæ¬¡åº”ç”¨çš„è§†å›¾å°ºå¯¸ï¼Œç”¨äºæ£€æµ‹æ¨ªç«–å±åˆ‡æ¢
    private var lastAppliedWidth: Int = 0
    private var lastAppliedHeight: Int = 0
    
    /**
     * ç»‘å®š DanmakuView
     * 
     *  [ä¿®å¤] æ”¯æŒæ¨ªç«–å±åˆ‡æ¢æ—¶é‡æ–°åº”ç”¨å¼¹å¹•æ•°æ®
     * å½“åŒä¸€ä¸ªè§†å›¾çš„å°ºå¯¸å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¹Ÿä¼šé‡æ–°è®¾ç½®å¼¹å¹•æ•°æ®
     */
    fun attachView(view: DanmakuView) {
        // ä½¿ç”¨ Log.w (warning) ç¡®ä¿æ—¥å¿—å¯è§
        Log.w(TAG, "========== attachView CALLED ==========")
        Log.w(TAG, "ğŸ“ View size: width=${view.width}, height=${view.height}, lastApplied=${lastAppliedWidth}x${lastAppliedHeight}")
        
        //  [å…³é”®ä¿®å¤] å¦‚æœæ˜¯åŒä¸€ä¸ªè§†å›¾ä½†å°ºå¯¸å‘ç”Ÿå˜åŒ–ï¼ˆæ¨ªç«–å±åˆ‡æ¢ï¼‰ï¼Œä¹Ÿéœ€è¦é‡æ–°åº”ç”¨å¼¹å¹•æ•°æ®
        val isSameView = danmakuView === view
        val sizeChanged = view.width != lastAppliedWidth || view.height != lastAppliedHeight
        val hasValidSize = view.width > 0 && view.height > 0
        
        if (isSameView && !sizeChanged && hasValidSize) {
            Log.w(TAG, "ğŸ“ attachView: Same view, same size, skipping")
            return
        }
        
        if (isSameView && sizeChanged && hasValidSize) {
            Log.w(TAG, "ğŸ“ attachView: Same view but size changed (rotation?), re-applying danmaku data")
            lastAppliedWidth = view.width
            lastAppliedHeight = view.height
            // [ä¿®å¤] å°ºå¯¸å˜åŒ–æ—¶ï¼Œé‡æ–°åº”ç”¨é…ç½®ï¼ˆè®¡ç®—è¡Œæ•°ï¼‰å’Œæ•°æ®
            applyConfigToController("resize")
            return
        }
        
        Log.w(TAG, "ğŸ“ attachView: new view, old=${danmakuView != null}, hashCode=${view.hashCode()}")
        
        danmakuView = view
        controller = view.controller
        applyDanmakuClickListener()
        
        Log.w(TAG, "ğŸ“ controller obtained: ${controller != null}")
        
        // å†…ç½®æ¸²æŸ“å±‚ï¼ˆScrollLayer, TopCenterLayer, BottomCenterLayerï¼‰ç”± DanmakuRenderEngine è‡ªåŠ¨æ³¨å†Œ
        // ä¸éœ€è¦æ‰‹åŠ¨æ·»åŠ ï¼Œæ‰‹åŠ¨æ·»åŠ ä¼šæŠ¥é”™ "The custom LayerType must not be less than 2000"
        
        // åº”ç”¨é…ç½®å¹¶åŒæ­¥å€é€ŸåŸºå‡†
        applyConfigToController("attachView")
        
        //  [å…³é”®ä¿®å¤] ç­‰å¾… View å¸ƒå±€å®Œæˆåå†è®¾ç½®å¼¹å¹•æ•°æ®
        // DanmakuRenderEngine éœ€è¦æœ‰æ•ˆçš„ View å°ºå¯¸æ¥è®¡ç®—å¼¹å¹•è½¨é“ä½ç½®
        if (hasValidSize) {
            // View å·²ç»æœ‰æœ‰æ•ˆå°ºå¯¸ï¼Œç›´æ¥è®¾ç½®æ•°æ®
            Log.w(TAG, "ğŸ“ View has valid size, setting data immediately")
            lastAppliedWidth = view.width
            lastAppliedHeight = view.height
            // [ä¿®å¤] ç«‹å³åº”ç”¨æ­£ç¡®çš„é…ç½®ï¼ˆå«é«˜åº¦ï¼‰å’Œæ•°æ®
            applyConfigToController("resize")
        } else {
            // View å°ºå¯¸ä¸º 0ï¼Œç­‰å¾…å¸ƒå±€å®Œæˆ
            Log.w(TAG, "ğŸ“ View size is 0, waiting for layout...")
            view.viewTreeObserver.addOnGlobalLayoutListener(object : android.view.ViewTreeObserver.OnGlobalLayoutListener {
                override fun onGlobalLayout() {
                    // ç§»é™¤ç›‘å¬å™¨ï¼Œé¿å…é‡å¤å›è°ƒ
                    view.viewTreeObserver.removeOnGlobalLayoutListener(this)
                    
                    Log.w(TAG, "ğŸ“ Layout callback! width=${view.width}, height=${view.height}")
                    
                    // ç¡®ä¿ View ä»ç„¶æ˜¯å½“å‰ç»‘å®šçš„ View
                    if (danmakuView === view && view.width > 0 && view.height > 0) {
                        lastAppliedWidth = view.width
                        lastAppliedHeight = view.height
                        // [ä¿®å¤] å¸ƒå±€å®Œæˆåï¼Œé‡æ–°åº”ç”¨é…ç½®ï¼ˆå«é«˜åº¦ï¼‰å’Œæ•°æ®
                        applyConfigToController("resize")
                    } else if (danmakuView === view) {
                        //  [ä¿®å¤] å¦‚æœå¸ƒå±€å›è°ƒæ—¶å°ºå¯¸ä»ä¸º 0ï¼Œå»¶è¿Ÿ 100ms å†è¯•ä¸€æ¬¡
                        Log.w(TAG, " View still zero size, scheduling delayed retry...")
                        view.postDelayed({
                            if (danmakuView === view && view.width > 0 && view.height > 0) {
                                Log.w(TAG, "ğŸ“ Delayed retry: width=${view.width}, height=${view.height}")
                                lastAppliedWidth = view.width
                                lastAppliedHeight = view.height
                                applyConfigToController("resize")
                            } else {
                                Log.w(TAG, " View still invalid after delay, skipping")
                            }
                        }, 100)
                    } else {
                        Log.w(TAG, " View changed, skipping setData")
                    }
                }
            })
        }
        
        Log.w(TAG, "========== attachView COMPLETED ==========")
    }
    
    /**
     * å°†ç¼“å­˜çš„å¼¹å¹•æ•°æ®åº”ç”¨åˆ° controllerï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰
     */
    private fun applyDanmakuDataToController() {
        Log.w(TAG, "ğŸ“ cachedDanmakuList is null? ${cachedDanmakuList == null}, size=${cachedDanmakuList?.size ?: 0}")
        cachedDanmakuList?.let { list ->
            //  [ä¿®å¤] å§‹ç»ˆç”¨ playTime=0 è®¾ç½®æ•°æ®ï¼Œå› ä¸ºå¼¹å¹•çš„ showAtTime æ˜¯ç›¸å¯¹äºè§†é¢‘å¼€å¤´çš„
            Log.w(TAG, "ğŸ“ Calling setData with ${list.size} items, playTime=0 (base reference)")
            controller?.setData(list, 0)
            Log.w(TAG, "ğŸ“ setData completed")
            
            // å¼ºåˆ¶åˆ·æ–°è§†å›¾
            controller?.invalidateView()
            Log.w(TAG, "ğŸ“ invalidateView called")
            
            // åŒæ­¥åˆ°å½“å‰æ’­æ”¾ä½ç½®
            player?.let { p ->
                val position = p.currentPosition
                Log.w(TAG, "ğŸ“ Player state: isPlaying=${p.isPlaying}, isEnabled=${config.isEnabled}, position=${position}ms")
                
                //  [ä¿®å¤] å§‹ç»ˆå…ˆ start åˆ°å½“å‰ä½ç½®ï¼Œè®© controller çŸ¥é“è§†é¢‘åœ¨å“ªé‡Œ
                controller?.start(position)
                Log.w(TAG, " controller.start($position) called")
                
                if (p.isPlaying && config.isEnabled) {
                    isPlaying = true
                    Log.w(TAG, " Danmaku playing")
                } else {
                    // å¦‚æœè§†é¢‘æš‚åœä¸­ï¼Œä¹Ÿæš‚åœå¼¹å¹•
                    controller?.pause()
                    isPlaying = false
                    Log.w(TAG, " Danmaku paused (player not playing)")
                }
            } ?: Log.w(TAG, "ğŸ“ Player is null, not syncing")
        } ?: Log.w(TAG, "ğŸ“ No cached danmaku list to apply")
    }
    
    /**
     * è§£ç»‘ DanmakuViewï¼ˆä¸é‡Šæ”¾å¼¹å¹•æ•°æ®ï¼‰
     */
    fun detachView() {
        Log.d(TAG, "ğŸ“ detachView: Pausing and clearing controller")
        controller?.pause()
        controller = null
        danmakuView = null
    }
    
    /**
     * âš™ï¸ [æ¼‚ç§»ä¿®å¤] å¯åŠ¨å®šæœŸæ¼‚ç§»æ£€æµ‹
     * æ¯ 5 ç§’æ£€æµ‹ä¸€æ¬¡ï¼Œä»…å½“æ’­æ”¾æ—¶åŒæ­¥
     * æ³¨æ„ï¼šä¸å†ä½¿ç”¨ setDataï¼Œé¿å…å¹²æ‰° Seek å¤„ç†
     */
    private fun startDriftSync() {
        syncJob?.cancel()
        syncJob = scope.launch {
            while (isActive) {
                delay(5000L)  // æ¯ 5 ç§’æ£€æµ‹ä¸€æ¬¡
                player?.let { p ->
                    if (p.isPlaying && config.isEnabled && isPlaying) {
                        val playerPos = p.currentPosition
                        // ä»…è°ƒç”¨ start() é‡æ–°åŒæ­¥ä½ç½®ï¼Œä¸é‡æ–°è®¾ç½®æ•°æ®
                        controller?.start(playerPos)
                        Log.d(TAG, "âš™ï¸ Drift sync at ${playerPos}ms")
                    }
                }
            }
        }
        Log.d(TAG, "âš™ï¸ Drift sync started")
    }
    
    /**
     * âš™ï¸ [æ¼‚ç§»ä¿®å¤] åœæ­¢å®šæœŸæ¼‚ç§»æ£€æµ‹
     */
    private fun stopDriftSync() {
        syncJob?.cancel()
        syncJob = null
        Log.d(TAG, "âš™ï¸ Drift sync stopped")
    }
    
    /**
     * ç»‘å®š ExoPlayer
     * 
     * [ä¿®å¤] æ·»åŠ åŒä¸€æ’­æ”¾å™¨å®ä¾‹æ£€æŸ¥ï¼Œé¿å…é‡å¤ç»‘å®š
     * å½“ä»å…¶ä»–è§†é¢‘è¿”å›æ—¶ï¼Œéœ€è¦é‡æ–°ç»‘å®šå½“å‰æ’­æ”¾å™¨
     */
    fun attachPlayer(exoPlayer: ExoPlayer) {
        Log.d(TAG, " attachPlayer: new=${exoPlayer.hashCode()}, old=${player?.hashCode()}")
        
        // [ä¿®å¤] ç§»é™¤"åŒä¸€æ’­æ”¾å™¨è·³è¿‡"çš„é€»è¾‘
        // åŸå› ï¼šåœ¨ Navigation åˆ‡æ¢è§†é¢‘åè¿”å›æ—¶ï¼Œè™½ç„¶ player å®ä¾‹ç›¸åŒï¼Œ
        // ä½† DanmakuManager çš„ playerListener å¯èƒ½å·²è¢«å…¶ä»–é¡µé¢çš„ player æ›¿æ¢ã€‚
        // å¿…é¡»é‡æ–°ç»‘å®šä»¥ç¡®ä¿å½“å‰ player çš„äº‹ä»¶èƒ½è¢«æ­£ç¡®å¤„ç†ã€‚
        
        // ç§»é™¤æ—§ç›‘å¬å™¨ï¼ˆæ— è®ºæ˜¯åŒä¸€æ’­æ”¾å™¨è¿˜æ˜¯ä¸åŒæ’­æ”¾å™¨ï¼‰
        playerListener?.let { 
            player?.removeListener(it)
            Log.d(TAG, " Removed old listener from player ${player?.hashCode()}")
        }
        
        player = exoPlayer
        
        // ğŸ¬ [æ ¹æœ¬ä¿®å¤] ä¸åœ¨è¿™é‡Œå¯åŠ¨å¸§åŒæ­¥ï¼Œè€Œæ˜¯åœ¨ onIsPlayingChanged ä¸­å¯åŠ¨
        
        playerListener = object : Player.Listener {
            override fun onIsPlayingChanged(isPlayerPlaying: Boolean) {
                Log.w(TAG, " onIsPlayingChanged: isPlaying=$isPlayerPlaying, isEnabled=${config.isEnabled}, hasData=${cachedDanmakuList != null}")
                
                if (isPlayerPlaying && config.isEnabled) {
                    //  [ä¿®å¤] åªæœ‰å½“æ•°æ®å·²åŠ è½½æ—¶æ‰å¯åŠ¨å¼¹å¹•
                    if (cachedDanmakuList != null) {
                        val position = exoPlayer.currentPosition
                        controller?.start(position)
                        isPlaying = true
                        // ğŸ¬ [æ ¹æœ¬ä¿®å¤] å¯åŠ¨å¸§çº§åŒæ­¥
                        startDriftSync()
                        Log.w(TAG, " Danmaku STARTED at ${position}ms with frame sync")
                    } else {
                        Log.w(TAG, " Player playing but danmaku data not loaded yet, will start after load")
                        // æ•°æ®åŠ è½½å®Œæˆåä¼šè‡ªåŠ¨ start
                    }
                } else if (!isPlayerPlaying) {
                    // æš‚åœ - DanmakuRenderEngine çš„ pause() ä¼šè®©å¼¹å¹•åœåœ¨åŸåœ°
                    controller?.pause()
                    isPlaying = false
                    // ğŸ¬ [æ ¹æœ¬ä¿®å¤] åœæ­¢å¸§çº§åŒæ­¥
                    stopDriftSync()
                    Log.w(TAG, " Danmaku PAUSED (danmakus stay in place)")
                }
            }
            
            override fun onPlaybackStateChanged(playbackState: Int) {
                Log.d(TAG, " onPlaybackStateChanged: state=$playbackState")
                when (playbackState) {
                    Player.STATE_READY -> {
                        if (exoPlayer.isPlaying && config.isEnabled) {
                            val position = exoPlayer.currentPosition
                            controller?.start(position)
                            isPlaying = true
                        }
                    }
                    Player.STATE_ENDED -> {
                        // è§†é¢‘ç»“æŸæ—¶æš‚åœå¼¹å¹•ï¼ˆä¿æŒåœ¨å±å¹•ä¸Šï¼‰
                        controller?.pause()
                        isPlaying = false
                    }
                    Player.STATE_BUFFERING -> {
                        // ç¼“å†²æ—¶æš‚åœå¼¹å¹•
                        if (isPlaying) {
                            controller?.pause()
                            Log.d(TAG, " Buffering, danmaku paused")
                        }
                    }
                }
            }
            
            override fun onPositionDiscontinuity(
                oldPosition: Player.PositionInfo,
                newPosition: Player.PositionInfo,
                reason: Int
            ) {
                val isSeekDiscontinuity =
                    reason == Player.DISCONTINUITY_REASON_SEEK ||
                        reason == Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT
                if (isSeekDiscontinuity) {
                    Log.w(TAG, " Seek detected: ${oldPosition.positionMs}ms -> ${newPosition.positionMs}ms")
                    
                    //  å…³é”®ä¿®å¤ï¼šSeek æ—¶é‡æ–°è°ƒç”¨ setData(list, 0) + start(newPosition)
                    cachedDanmakuList?.let { list ->
                        Log.w(TAG, " Re-setting data with playTime=0, then start at ${newPosition.positionMs}ms")
                        controller?.setData(list, 0)  // å§‹ç»ˆç”¨ 0 ä½œä¸ºåŸºå‡†
                        controller?.start(newPosition.positionMs)  // ç”¨å®é™…ä½ç½®å¯åŠ¨
                        
                        if (exoPlayer.isPlaying && config.isEnabled) {
                            isPlaying = true
                            Log.w(TAG, " Danmaku restarted at ${newPosition.positionMs}ms")
                        } else {
                            controller?.pause()
                            isPlaying = false
                            Log.w(TAG, " Danmaku paused after seek (player not playing)")
                        }
                    } ?: run {
                        controller?.clear()
                        Log.w(TAG, " No cached danmaku, just cleared screen")
                    }
                }
            }
            
            //  [æ–°å¢] è§†é¢‘å€é€Ÿå˜åŒ–æ—¶åŒæ­¥å¼¹å¹•é€Ÿåº¦
            //  [é—®é¢˜10ä¿®å¤] ä¼˜åŒ–é•¿æŒ‰åŠ é€Ÿè§†é¢‘æ—¶çš„å¼¹å¹•åŒæ­¥
            override fun onPlaybackParametersChanged(playbackParameters: androidx.media3.common.PlaybackParameters) {
                val videoSpeed = playbackParameters.speed
                Log.w(TAG, "â© onPlaybackParametersChanged: videoSpeed=$videoSpeed, previous=$currentVideoSpeed")
                
                //  åŒæ­¥å¼¹å¹•é€Ÿåº¦ï¼šè§†é¢‘ 2x æ—¶ï¼Œå¼¹å¹•ä¹Ÿéœ€è¦ 2 å€é€Ÿæ»šåŠ¨
                // é€šè¿‡å‡å°‘ moveTime æ¥åŠ å¿«å¼¹å¹•æ»šåŠ¨
                if (videoSpeed != currentVideoSpeed) {
                    currentVideoSpeed = videoSpeed
                    
                    controller?.let { ctrl ->
                        // æ ¹æ®è§†é¢‘å€é€Ÿè°ƒæ•´å¼¹å¹•æ»šåŠ¨æ—¶é—´
                        // è§†é¢‘ 2x å€é€Ÿ = å¼¹å¹•æ»šåŠ¨æ—¶é—´å‡åŠ
                        val adjustedMoveTime = (originalMoveTime / videoSpeed).toLong()
                        ctrl.config.scroll.moveTime = adjustedMoveTime
                        
                        // [å…³é”®ä¿®å¤] ä»»ä½•å€é€Ÿå˜åŒ–éƒ½éœ€è¦ç«‹å³åŒæ­¥å¼¹å¹•åˆ°å½“å‰è§†é¢‘ä½ç½®
                        // å› ä¸ºè§†é¢‘å€é€Ÿå˜åŒ–åï¼Œå¼¹å¹•å¼•æ“çš„å†…éƒ¨æ—¶é—´çº¿ä¸è§†é¢‘æ—¶é—´çº¿ä¼šäº§ç”Ÿåå·®
                        // ä¾‹å¦‚ï¼š2å€é€Ÿæ’­æ”¾5åˆ†é’Ÿåï¼Œè§†é¢‘åœ¨10åˆ†é’Ÿå¤„ï¼Œä½†å¼¹å¹•å¼•æ“å¯èƒ½è¿˜åœ¨5åˆ†é’Ÿå¤„
                        val currentPos = exoPlayer.currentPosition
                        Log.w(TAG, "â© Speed changed, resyncing danmaku at ${currentPos}ms")
                        cachedDanmakuList?.let { list ->
                            ctrl.setData(list, 0)
                            ctrl.start(currentPos)
                            if (!exoPlayer.isPlaying) {
                                ctrl.pause()
                            }
                        }
                        
                        ctrl.invalidateView()
                        Log.w(TAG, "â© Danmaku moveTime: original=$originalMoveTime, adjusted=$adjustedMoveTime (video=${videoSpeed}x)")
                    }
                }
            }
        }
        
        exoPlayer.addListener(playerListener!!)
    }
    
    /**
     * åŠ è½½å¼¹å¹•æ•°æ®
     * 
     * @param cid è§†é¢‘ cid
     * @param aid è§†é¢‘ aid (ç”¨äºè·å–å¼¹å¹•é«˜çº§å…ƒæ•°æ®)
     * @param durationMs è§†é¢‘æ—¶é•¿ (æ¯«ç§’)ï¼Œç”¨äºè®¡ç®— Protobuf åˆ†æ®µæ•°ã€‚å¦‚æœä¸º 0ï¼Œåˆ™å›é€€åˆ° XML API
     */
    fun loadDanmaku(cid: Long, aid: Long, durationMs: Long = 0L) {
        Log.w(TAG, "========== loadDanmaku CALLED cid=$cid, aid=$aid, duration=${durationMs}ms ==========")
        Log.w(TAG, " loadDanmaku: cid=$cid, cached=$cachedCid, isLoading=$isLoading, controller=${controller != null}")
        
        // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œä¼˜å…ˆå¤„ç†æ–° cid
        if (isLoading) {
            if (cid != cachedCid) {
                Log.w(TAG, " Loading in progress for cid=$cachedCid, canceling to load cid=$cid")
                loadJob?.cancel()
                isLoading = false
            } else {
                Log.w(TAG, " Already loading same cid=$cid, skipping")
                return
            }
        }
        
        // å¦‚æœæ˜¯åŒä¸€ä¸ª cid ä¸”å·²æœ‰ç¼“å­˜æ•°æ®ï¼Œç›´æ¥ä½¿ç”¨ï¼ˆæ¨ªç«–å±åˆ‡æ¢åœºæ™¯ï¼‰
        if (cid == cachedCid && cachedDanmakuList != null) {
            val currentPos = player?.currentPosition ?: 0L
            Log.w(TAG, " Using cached danmaku list (${cachedDanmakuList!!.size} items) for cid=$cid, position=${currentPos}ms")
            
            //  [ä¿®å¤] ä»¿ç…§ Seek å¤„ç†å™¨çš„æ¨¡å¼ï¼šå…ˆç”¨ 0 è®¾ç½®åŸºå‡†ï¼Œå†ç”¨ currentPos å¯åŠ¨
            controller?.setData(cachedDanmakuList!!, 0)  // åŸºå‡†æ—¶é—´ 0
            controller?.start(currentPos)  // è·³åˆ°å½“å‰ä½ç½®
            Log.w(TAG, " Cached data: setData(0) + start(${currentPos}ms)")
            
            player?.let { p ->
                if (p.isPlaying && config.isEnabled) {
                    isPlaying = true
                    Log.w(TAG, " Player playing, danmaku active")
                } else {
                    controller?.pause()
                    isPlaying = false
                    Log.w(TAG, " Player paused, danmaku paused")
                }
            }
            return
        }
        
        // éœ€è¦ä»ç½‘ç»œåŠ è½½æ–° cid çš„å¼¹å¹•
        Log.w(TAG, " loadDanmaku: New cid=$cid, loading from network")
        isLoading = true
        cachedCid = cid
        cachedDanmakuList = null
        sourceDanmakuList = null
        sourceAdvancedDanmakuList = null
        _advancedDanmakuFlow.value = emptyList()
        
        // æ¸…é™¤ç°æœ‰å¼¹å¹•
        controller?.stop()
        
        loadJob?.cancel()
        loadJob = scope.launch {
            try {
                // 1. è·å–å¼¹å¹•å…ƒæ•°æ® (High-Energy, Command Dms)
                var commandDmList: List<AdvancedDanmakuData> = emptyList()
                val viewReply = if (aid > 0) {
                     com.android.purebilibili.data.repository.DanmakuRepository.getDanmakuView(cid, aid)
                } else null
                
                if (viewReply != null) {
                    Log.w(TAG, " Got Danmaku Metadata: count=${viewReply.count}, segments=${viewReply.dmSge?.total ?: "N/A"}")
                    
                    // å¤„ç† Command Dms (å¦‚é«˜èƒ½è¿›åº¦æ¡æç¤º, äº’åŠ¨å¼¹å¹•)
                    if (viewReply.commandDms.isNotEmpty()) {
                        commandDmList = viewReply.commandDms.mapNotNull { cmd ->
                            buildCommandDanmaku(cmd)
                        }
                        Log.w(
                            TAG,
                            " Converted ${commandDmList.size}/${viewReply.commandDms.size} Command Dms to AdvancedDanmakuData"
                        )
                    }
                    
                    // TODO: specialDms é€šå¸¸æ˜¯ URL åˆ—è¡¨ï¼Œéœ€è¦é¢å¤–ä¸‹è½½è§£æï¼Œæš‚è·³è¿‡
                }
                
                val (segments, rawData) = withContext(Dispatchers.IO) {
                    var segmentList: List<ByteArray>? = null
                    var xmlData: ByteArray? = null
                    
                    //  [æ–°å¢] ä¼˜å…ˆä½¿ç”¨ Protobuf API (seg.so)
                    if (durationMs > 0 || viewReply != null) {
                        Log.w(TAG, " Trying Protobuf API (seg.so)...")
                        try {
                            val fetched = com.android.purebilibili.data.repository.DanmakuRepository.getDanmakuSegments(
                                cid = cid,
                                durationMs = durationMs,
                                metadataSegmentCount = viewReply?.dmSge?.total?.toInt()
                            )
                            if (fetched.isNotEmpty()) {
                                segmentList = fetched
                            }
                        } catch (e: Exception) {
                            Log.w(TAG, " Protobuf API failed: ${e.message}, falling back to XML")
                        }
                    }
                    
                    //  [åå¤‡] å¦‚æœ Protobuf å¤±è´¥æˆ–æœªæä¾› durationï¼Œä½¿ç”¨ XML API
                    if (segmentList.isNullOrEmpty()) {
                        Log.w(TAG, " Trying XML API (fallback)...")
                        xmlData = com.android.purebilibili.data.repository.DanmakuRepository.getDanmakuRawData(cid)
                    }
                    
                    Pair(segmentList, xmlData)
                }
                
                val parsedResult = withContext(Dispatchers.Default) {
                    when {
                        !segments.isNullOrEmpty() -> {
                            val parsed = DanmakuParser.parseProtobuf(segments)
                            Log.w(TAG, " Protobuf parsed: Standard=${parsed.standardList.size}, Advanced=${parsed.advancedList.size}")
                            parsed
                        }
                        rawData != null && rawData.isNotEmpty() -> {
                            val parsed = DanmakuParser.parse(rawData)
                            Log.w(TAG, " XML parsed: Standard=${parsed.standardList.size}, Advanced=${parsed.advancedList.size}")
                            parsed
                        }
                        else -> ParsedDanmaku(emptyList(), emptyList())
                    }
                }
                
                sourceDanmakuList = parsedResult.standardList
                sourceAdvancedDanmakuList = parsedResult.advancedList + commandDmList

                val rebuilt = withContext(Dispatchers.Default) {
                    rebuildDanmakuCacheFromSource("load")
                }

                if (!rebuilt) {
                    Log.w(TAG, " No danmaku data available for cid=$cid")
                    withContext(Dispatchers.Main) {
                        isLoading = false
                    }
                    return@launch
                }
                
                withContext(Dispatchers.Main) {
                    isLoading = false
                    
                    //  [æ ¸å¿ƒä¿®å¤] ä»¿ç…§ Seek å¤„ç†å™¨çš„æ¨¡å¼
                    val currentPlayTime = player?.currentPosition ?: 0L
                    Log.w(TAG, "ğŸ“ View size: width=${danmakuView?.width}, height=${danmakuView?.height}")
                    
                    //  [æ ¸å¿ƒä¿®å¤] å…ˆç”¨ 0 ä½œä¸ºåŸºå‡†è®¾ç½®æ•°æ®ï¼Œå†ç”¨å®é™…ä½ç½®å¯åŠ¨
                    // è¿™ä¸ Seek å¤„ç†å™¨çš„æ¨¡å¼ä¸€è‡´ï¼Œç¡®ä¿å¼•æ“çŸ¥é“å®Œæ•´çš„æ—¶é—´çº¿
                    // æ³¨æ„ï¼šè¿™é‡Œå¿…é¡»ä½¿ç”¨ç¼“å­˜åçš„æœ€ç»ˆåˆ—è¡¨ï¼ˆå¯èƒ½å·²ç»å»é‡åˆå¹¶ï¼‰
                    val finalList = cachedDanmakuList ?: emptyList()
                    if (finalList.isEmpty()) {
                        controller?.clear()
                        isPlaying = false
                        Log.w(TAG, "ğŸ“ Final danmaku list empty after rebuild, cleared controller")
                        return@withContext
                    }
                    Log.w(TAG, "ğŸ“ Calling setData with ${finalList.size} items, playTime=0 (base)")
                    controller?.setData(finalList, 0)  // åŸºå‡†æ—¶é—´ 0
                    Log.w(TAG, "ğŸ“ setData completed")
                    
                    //  [å…³é”®] å¼ºåˆ¶åˆ·æ–°è§†å›¾ - ä¸æ¨ªç«–å±åˆ‡æ¢è·¯å¾„ä¸€è‡´
                    controller?.invalidateView()
                    Log.w(TAG, "ğŸ“ invalidateView called")
                    
                    // start åŒæ­¥åˆ°å½“å‰ä½ç½®
                    controller?.start(currentPlayTime)
                    Log.w(TAG, " controller.start($currentPlayTime) called - video is at this position")
                    
                    // å¦‚æœ player æš‚åœä¸­ï¼Œä¹Ÿæš‚åœ controller
                    if (player?.isPlaying != true) {
                        controller?.pause()
                        isPlaying = false
                        Log.w(TAG, " Player not playing, controller paused")
                    } else {
                        isPlaying = true
                        Log.w(TAG, " Player is playing, danmaku active")
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, " Failed to load danmaku for cid=$cid: ${e.message}", e)
                withContext(Dispatchers.Main) {
                    isLoading = false
                }
            }
        }
    }
    
    fun show() {
        Log.d(TAG, "ğŸ‘ï¸ show()")
        danmakuView?.visibility = android.view.View.VISIBLE
        
        if (player?.isPlaying == true) {
            val position = player?.currentPosition ?: 0L
            controller?.start(position)
            isPlaying = true
        }
    }
    
    fun hide() {
        Log.d(TAG, "ğŸ™ˆ hide()")
        controller?.pause()
        danmakuView?.visibility = android.view.View.GONE
        isPlaying = false
    }
    
    /**
     *  æ¸…é™¤å½“å‰æ˜¾ç¤ºçš„å¼¹å¹•ï¼ˆæ‹–åŠ¨è¿›åº¦æ¡æ—¶è°ƒç”¨ï¼‰
     */
    fun clear() {
        Log.d(TAG, "ğŸ§¹ clear() - clearing displayed danmakus")
        controller?.clear()
    }
    
    /**
     *  è·³è½¬åˆ°æŒ‡å®šæ—¶é—´ï¼ˆæ‹–åŠ¨è¿›åº¦æ¡å®Œæˆæ—¶è°ƒç”¨ï¼‰
     * ä¼šæ¸…é™¤å½“å‰å¼¹å¹•å¹¶ä»æ–°ä½ç½®å¼€å§‹æ˜¾ç¤º
     * 
     * @param positionMs ç›®æ ‡ä½ç½®ï¼ˆæ¯«ç§’ï¼‰
     */
    fun seekTo(positionMs: Long) {
        Log.w(TAG, "â­ï¸ seekTo($positionMs) - refreshing danmaku")
        
        cachedDanmakuList?.let { list ->
            // å…ˆæ¸…é™¤å½“å‰æ˜¾ç¤ºçš„å¼¹å¹•
            controller?.clear()
            // é‡æ–°è®¾ç½®æ•°æ®åŸºå‡†
            controller?.setData(list, 0)
            // ä»æ–°ä½ç½®å¼€å§‹
            controller?.start(positionMs)
            
            // æ ¹æ®æ’­æ”¾å™¨çŠ¶æ€å†³å®šæ˜¯å¦æš‚åœ
            if (player?.isPlaying == true && config.isEnabled) {
                isPlaying = true
                Log.w(TAG, "â­ï¸ Danmaku restarted at ${positionMs}ms")
            } else {
                controller?.pause()
                isPlaying = false
                Log.w(TAG, "â­ï¸ Danmaku paused at ${positionMs}ms (player not playing)")
            }
        } ?: run {
            controller?.clear()
            Log.w(TAG, "â­ï¸ No cached danmaku, just cleared")
        }
    }
    
    /**
     * [æ–°å¢] æ·»åŠ æœ¬åœ°å¼¹å¹•ï¼ˆå‘é€æˆåŠŸåç«‹å³æ˜¾ç¤ºï¼‰
     * 
     * æ­¤æ–¹æ³•ç”¨äºåœ¨ç”¨æˆ·å‘é€å¼¹å¹•åç«‹å³å°†å…¶æ˜¾ç¤ºåœ¨å±å¹•ä¸Šï¼Œ
     * æ— éœ€ç­‰å¾…æœåŠ¡å™¨åˆ·æ–°å¼¹å¹•åˆ—è¡¨ã€‚
     * 
     * @param text å¼¹å¹•å†…å®¹
     * @param color å¼¹å¹•é¢œè‰² (åè¿›åˆ¶ RGBï¼Œé»˜è®¤ç™½è‰² 16777215)
     * @param mode å¼¹å¹•æ¨¡å¼: 1=æ»šåŠ¨(é»˜è®¤), 4=åº•éƒ¨, 5=é¡¶éƒ¨
     * @param fontSize å­—å·: 18=å°, 25=ä¸­(é»˜è®¤), 36=å¤§
     */
    fun addLocalDanmaku(
        text: String,
        color: Int = 16777215,
        mode: Int = 1,
        fontSize: Int = 25
    ) {
        val currentPosition = player?.currentPosition ?: run {
            Log.w(TAG, "ğŸ“ addLocalDanmaku: player is null, cannot add danmaku")
            return
        }
        
        Log.d(TAG, "ğŸ“ addLocalDanmaku: text=$text, color=$color, mode=$mode, fontSize=$fontSize, position=${currentPosition}ms")
        
        // ä½¿ç”¨ TextData (DanmakuData çš„å…·ä½“å®ç°)
        val danmakuData = com.bytedance.danmaku.render.engine.render.draw.text.TextData().apply {
            //  [ä¿®å¤] è®¾ç½®æ˜¾ç¤ºæ—¶é—´ä¸ºå½“å‰æ’­æ”¾ä½ç½® + 100ms åç§»
            // è¿™ç¡®ä¿å¼¹å¹•ä¸ä¼šå› ä¸º"å·²ç»è¿‡å»"è€Œè¢«è·³è¿‡
            showAtTime = currentPosition + 100L
            
            // è®¾ç½®å¼¹å¹•å†…å®¹ - [ä¿®æ”¹] ä½¿ç”¨ã€ã€åŒ…è£¹ä½œä¸ºæ ‡è®°ï¼Œæ›´ç¾è§‚
            this.text = "ã€ $text ã€"
            
            // è®¾ç½®é¢œè‰² (ARGB æ ¼å¼)
            textColor = color or 0xFF000000.toInt()
            
            // å°è¯•è®¾ç½®è¾¹æ¡†/èƒŒæ™¯
            try {
                val greenBorder = 0xFF4CAF50.toInt()
                val clazz = this::class.java
                
                // å°è¯•å¤šä¸ªå¯èƒ½çš„å­—æ®µå - å¸Œæœ›èƒ½å‘½ä¸­ä¸€ä¸ª
                // 1. borderColor (è¾¹æ¡†é¢œè‰²)
                // 2. strokeColor (å¯èƒ½æ˜¯æ–‡å­—æè¾¹ï¼Œä¹Ÿå¯èƒ½æ˜¯æ¡†) -> å…ˆå‰å°è¯•æœªç”Ÿæ•ˆæˆ–è¢«è¦†ç›–
                // 3. backgroundColor (èƒŒæ™¯è‰²)
                val fieldNames = listOf("borderColor", "backgroundColor", "backColor", "padding")
                
                for (name in fieldNames) {
                    try {
                        val field = clazz.getDeclaredField(name)
                        field.isAccessible = true
                        
                        if (name == "padding") {
                             field.setFloat(this, 10f)
                        } else {
                             field.setInt(this, greenBorder)
                        }
                        Log.d(TAG, "ğŸ“ Reflex set $name to Green/Value")
                    } catch (e: Exception) {
                        // ignore
                    }
                }
            } catch (e: Exception) {
                // å¿½ç•¥
            }
            
            // è®¾ç½®å¼¹å¹•ç±»å‹ - ä½¿ç”¨åº“çš„å¸¸é‡
            layerType = when (mode) {
                4 -> com.bytedance.danmaku.render.engine.utils.LAYER_TYPE_BOTTOM_CENTER  // åº•éƒ¨
                5 -> com.bytedance.danmaku.render.engine.utils.LAYER_TYPE_TOP_CENTER     // é¡¶éƒ¨
                else -> com.bytedance.danmaku.render.engine.utils.LAYER_TYPE_SCROLL      // æ»šåŠ¨ (é»˜è®¤)
            }
        }
        
        // æ·»åŠ åˆ°ç¼“å­˜åˆ—è¡¨å¹¶æ’åº
        // [æ ¸å¿ƒä¿®å¤] å¿…é¡»æŒ‰æ—¶é—´æ’åºï¼æ¸²æŸ“å¼•æ“ä¾èµ–é¡ºåºæ•°æ®ï¼Œä¹±åºä¼šå¯¼è‡´å¼¹å¹•æ— æ³•æ˜¾ç¤º
        cachedDanmakuList = (cachedDanmakuList ?: emptyList()).plus(danmakuData).sortedBy { it.showAtTime }
        sourceDanmakuList = (sourceDanmakuList ?: emptyList()).plus(danmakuData).sortedBy { it.showAtTime }
        Log.d(TAG, "ğŸ“ Added to cache and sorted, total: ${cachedDanmakuList?.size} danmakus")
        
        // ç«‹å³æ˜¾ç¤ºï¼ˆé€šè¿‡é‡æ–°è®¾ç½®æ•°æ®å¹¶è·³åˆ°å½“å‰ä½ç½®ï¼‰
        cachedDanmakuList?.let { list ->
            Log.d(TAG, "ğŸ“ Calling setData with ${list.size} items")
            controller?.setData(list, 0)
            controller?.start(currentPosition)
            
            //  [å…³é”®ä¿®å¤] å¼ºåˆ¶åˆ·æ–°è§†å›¾ï¼Œç¡®ä¿æ–°å¼¹å¹•ç«‹å³æ¸²æŸ“
            controller?.invalidateView()
            Log.d(TAG, "ğŸ“ invalidateView called")
            
            if (player?.isPlaying == true && config.isEnabled) {
                isPlaying = true
                Log.d(TAG, "ğŸ“ Danmaku playing")
            } else {
                controller?.pause()
                Log.d(TAG, "ğŸ“ Danmaku paused (player not playing)")
            }
        }
        
        Log.d(TAG, "ğŸ“ Local danmaku added and displayed")
    }
    
    /**
     * æ¸…é™¤è§†å›¾å¼•ç”¨ï¼ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼‰
     */
    fun clearViewReference() {
        Log.d(TAG, " clearViewReference: Clearing all references")
        
        // ç§»é™¤æ’­æ”¾å™¨ç›‘å¬å™¨
        playerListener?.let { listener ->
            player?.removeListener(listener)
        }
        playerListener = null
        player = null
        
        // åœæ­¢å¼¹å¹•
        controller?.stop()
        controller = null
        danmakuView = null
        
        //  [ä¿®å¤] é‡ç½®å°ºå¯¸è®°å½•
        lastAppliedWidth = 0
        lastAppliedHeight = 0
        
        // å–æ¶ˆåŠ è½½ä»»åŠ¡
        loadJob?.cancel()
        loadJob = null
        
        // ğŸ¬ [æ ¹æœ¬ä¿®å¤] åœæ­¢å¸§çº§åŒæ­¥
        stopDriftSync()
        
        isPlaying = false
        isLoading = false
        
        Log.d(TAG, " All references cleared")
    }
    
    /**
     * è®¾ç½®å¼¹å¹•ç‚¹å‡»ç›‘å¬å™¨
     *
     * @param listener å›è°ƒå‡½æ•°ï¼Œå‚æ•°ä¸º (text, dmid, uid, isSelf)
     */
    fun setOnDanmakuClickListener(listener: (String, Long, Long, Boolean) -> Unit) {
        danmakuClickListener = listener
        applyDanmakuClickListener()
    }

    private fun applyDanmakuClickListener() {
        val callback = danmakuClickListener ?: return
        controller?.let { ctrl ->
            try {
                ctrl.itemClickListener = object : IItemClickListener {
                    override fun onDanmakuClick(
                        danmaku: DanmakuData,
                        rect: android.graphics.RectF,
                        point: android.graphics.PointF
                    ) {
                        val textData = danmaku as? TextData
                        val weighted = textData as? WeightedTextData
                        val text = textData?.text.orEmpty()
                        val dmid = weighted?.danmakuId ?: 0L
                        val uid = weighted?.userHash?.toLongOrNull() ?: 0L
                        val currentMid = com.android.purebilibili.core.store.TokenManager.midCache ?: 0L
                        val isSelf = uid != 0L && uid == currentMid
                        callback(text, dmid, uid, isSelf)
                    }
                }
                Log.d(TAG, "setOnDanmakuClickListener set (DanmakuRenderEngine)")
            } catch (e: Exception) {
                Log.e(TAG, "Failed to set listener", e)
            }
        }
    }



    /**
     * é‡Šæ”¾æ‰€æœ‰èµ„æº
     */
    fun release() {
        Log.d(TAG, " release")
        clearViewReference()
        pluginObserverJob?.cancel()
        pluginObserverJob = null
        
        // æ¸…é™¤ç¼“å­˜
        cachedDanmakuList = null
        sourceDanmakuList = null
        sourceAdvancedDanmakuList = null
        rawDanmakuList = null
        _advancedDanmakuFlow.value = emptyList()
        cachedCid = 0L
        
        Log.d(TAG, " DanmakuManager fully released")
    }
}

/**
 * Composable è¾…åŠ©å‡½æ•°ï¼šè·å–å¼¹å¹•ç®¡ç†å™¨å®ä¾‹
 */
@Composable
fun rememberDanmakuManager(): DanmakuManager {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    
    val manager = remember { 
        DanmakuManager.getInstance(context, scope) 
    }
    
    // ç¡®ä¿ scope æ˜¯æœ€æ–°çš„
    DisposableEffect(scope) {
        DanmakuManager.updateScope(scope)
        onDispose { }
    }
    
    return manager
}
